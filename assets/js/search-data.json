{"0": {
    "doc": "Asynchronous and Privileged Execution",
    "title": "Asynchronous and Privileged Execution",
    "content": "Yoda uses delayed- and remote rule execution. There are different reasons to apply these constructs, and different ways to use these. Currently there is a bug in iRods whereby output parameters are not passed to delayed- or remote rules. This document explains where and how these constructs are applied. ",
    "url": "/yoda/design/processes/async-system-execution.html",
    "relUrl": "/design/processes/async-system-execution.html"
  },"1": {
    "doc": "Asynchronous and Privileged Execution",
    "title": "Concerns",
    "content": "The following concerns need to be dealt with: . | Security: we must protect the integrity/availability of data in the vault. | Interactivity: the interactive user should not wait for tasks. | Scalability: tasks with long execution time should not block other processes. | Tracability: it should be tracable who was responsible for certain changes. | . To address these concerns, we made the following decisions: . | Decision: asynchronous execution of tasks with long- or uncertain execution time. Tasks that require long (say: more than 2 sec) or uncertain execution must be executed asynchronous from the interactive session. Rationale: this allows the interactive session to continue (Concern 2), and these jobs to be scheduled/prioritized (Concern 3). Impact: The interactive user is not informed of the result of the task, but that the task is pending. The user should be informed of the end-result via alternative channels. | Decision: exclusive privileges for vault. Tasks in the vault require exclusive privileges. These privileges may only be assigned to actors that can be trusted. Rationale: Data in the vault must be protected from undesired changes that may damage the integrity/authenticity that is required for reuse of the data (Concern 1). Impact: Privileges may not be assigned to an interactive user, as credentials may be compromised and to prevent human errors. Privileges must be limited to defined procedures that can be trusted to maintain integrity/authenticity. The system must register who ordered such a procedure (Concern 4). | . ",
    "url": "/yoda/design/processes/async-system-execution.html#concerns",
    "relUrl": "/design/processes/async-system-execution.html#concerns"
  },"2": {
    "doc": "Asynchronous and Privileged Execution",
    "title": "Solutions",
    "content": "We identified the following constructs to provide privileged and/or asynchronous execution: . | ExecCmd-of-irule for privileged execution. | Delayed Rule for asynchronous execution. Currently this does not work in all cases, due to a bug with for delayed rules with output parameters in the top-level call. | Cronjob for asynchronous AND privileged execution. This allows a job to be ‘picked up’ and executed within the system environment. Drawback: asynchronous, cronjobs can only be scheduled at minute-granularity, so certain jobs require ~1m to start. We use cronjobs as a fallback when we cannot use delayed rules due to a bug in irods. | . The table below describes the ideal application of the above constructs. For now, the the cronjob is sometimes used for all async executions (bottom line). |   | User Environment | System Environment | . | Synchronous | Default | Use ExecCmd | . | ASynchronous | Delayed Rule | Delayed Rule + ExecCmd | . ",
    "url": "/yoda/design/processes/async-system-execution.html#solutions",
    "relUrl": "/design/processes/async-system-execution.html#solutions"
  },"3": {
    "doc": "Asynchronous and Privileged Execution",
    "title": "Further Work",
    "content": ". | Discuss the motivation for using the system/iRods user to increase privileges. Should we ideally use a specific user/role with specific privileges for the vault? | Discuss how the state model is reflected in the publication space. | Discuss applying ‘pending’ states to the toVault as well, in line with the pending states for publication. | Deletion of Data Package from the vault not yet implemented. | Create state model for revisions and replications. | Create state model for updating metadata. | . ",
    "url": "/yoda/design/processes/async-system-execution.html#further-work",
    "relUrl": "/design/processes/async-system-execution.html#further-work"
  },"4": {
    "doc": "Asynchronous and Privileged Execution",
    "title": "Appendix: Overview of rules and solutions",
    "content": "The image below shows the state model, and indicates the actions that require asynchronous execution and/or privileges. The table below described the individual actions. | # | Action | (a)sync | Context | State Change | Comment | . | 1a | Research2Vault (request) | sync | user |   | Register Action and request execution | . | 1b | Research2Vault (execution) | async | system | ACCEPTED - SECUREDNew object: UNPUBLISHED | Copy files | . | 2a | Vault2Research (request) | sync | user |   | Register action and request execution | . | 2b | Vault2Research (execution) | async | user | New object: LOCKED | Copy files | . | 3a | SubmitPublication (request) | sync | user |   | Register action and request execution | . | 3b | SubmitPublication (execution) | sync | system | UNPUBLISHED - SUBMITTED_FOR_PUBLICATION |   | . | 4a | ApprovePublication (request) | sync | user |   | Register action ande request execution | . | 4b | ApprovePublication (execution) | sync | system | SUBMITTED_FOR_PUBLICATION - APPROVED_FOR_PUBLICATION | trigger Publish | . | 5 | Publish | async | system | APPROVED_FOR_PUBLICATION - PUBLISHED | Create/Register DOI, PMH, etc.there is no registered within for public area?! | . | 6a | RejectPublication (request) | sync | user |   | Register action and request execution | . | 6b | RejectPublication (execution) | sync | system | SUBMITTED_FOR_PUBLICATION - UNPUBLISHED | (is nog async, kan tzt sync worden) | . | 7a | Published2pending (request) | sync | user |   | Register action and request execution | . | 7b | Published2pending (execute) | sync | system | PUBLISHED - PENDING_DEPUBLICATION |   | . | 7c | Pending2depublished | async | system | PENDING_DEPUBLICATION - DEPUBLISHED | Update/register DOI, PMH, etc. | . | 8a | Republish2pending (requestt) | sync | user |   | Register action and request execution | . | 8b | Republish2pending (execution) | sync | system | DEPUBLISHED - PENDING_REPUBLICATION | trigger pending2published | . | 8c | Pending2published | async | system | PENDING_REPUBLICATION - PUBLISHED | Update/register DOI, PMH, etc., | . | 9 | Revisioning | async | user |   |   | . | 10 | Replication | async | user |   |   | . | 11a | Update Vault Metadata (request) | sync | user |   | Register action and request execution | . | 11b | Update Vault Metadata (execution) | sync | system |   | Create metadata updates and trigger publication actions | . | 11c | Update Vault Metadata (publishing) | async | system |   | Update/register DOI, PMH, etc. | . Note that all actions that require async/system execution are preceded by a synchronous user action that registers the action, and triggers the async/system action: 1, 2, 3, 4, , 6, 7, 8. Actions are registered (in principle) in iCat, in provenance (user actions) and in system log. Registration in system log not always consequently. ",
    "url": "/yoda/design/processes/async-system-execution.html#appendix-overview-of-rules-and-solutions",
    "relUrl": "/design/processes/async-system-execution.html#appendix-overview-of-rules-and-solutions"
  },"5": {
    "doc": "Asynchronous processes",
    "title": "Asynchronous processes",
    "content": "This page contains an overview of asynchronous processes in Yoda. ",
    "url": "/yoda/design/processes/asynchronous-processes.html",
    "relUrl": "/design/processes/asynchronous-processes.html"
  },"6": {
    "doc": "Asynchronous processes",
    "title": "Table of contents",
    "content": ". | Metadata | Metadata schema update job | Replication | Replication job | Revision management | Revision management - creation job | Revision management - cleanup job | Statistics | Statistics job | Archiving | Archiving - retry-copy-to-vault job | Archiving - intake to vault job | Archiving - publication job | . ",
    "url": "/yoda/design/processes/asynchronous-processes.html#table-of-contents",
    "relUrl": "/design/processes/asynchronous-processes.html#table-of-contents"
  },"7": {
    "doc": "Asynchronous processes",
    "title": "Metadata",
    "content": "Metadata changes are handled synchronously, except for batch updates of data package metadata after schema updates. Schema update job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/check-metadata-for-schema-updates.r | . | Purpose | verify and update data package metadata to new schema versions | . | Lock file | no locking | . | Scheduling | delayed rule queue | . | Typically started by | manually by application administrator, after schema or application upgrade | . Any changes to data package metadata will be recorded in the rodsLog. ",
    "url": "/yoda/design/processes/asynchronous-processes.html#metadata",
    "relUrl": "/design/processes/asynchronous-processes.html#metadata"
  },"8": {
    "doc": "Asynchronous processes",
    "title": "Replication",
    "content": "By default, data in Yoda is replicated across two servers. Policies add a metadata attribute to data objects that should be replicated, and the asynchronous replication job replicates these objects. The default name of the metadata attribute is org_replication_scheduled; the attribute value contains the source and destination resource, separated by commas. Replication job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/async-data-replicate.py | . | Purpose | replicate data objects to consumer | . | Lock file | /tmp/irods-async-data-replicate.py.lock | . | Scheduling | cronjob, data object queue based on data object metadata attributes | . | Typically started by | cronjob runs every five minutes | . Data objects are marked for revision creation using a metadata attribute. The default name of these attributes is org_replication_scheduled. The script has a verbose mode (which can be enabled using the -v switch). This will log additional information for troubleshooting to the rodsLog. If a flag data object named /ZONE/yoda/flags/stop_replication is present, the script will stop processing data objects. ",
    "url": "/yoda/design/processes/asynchronous-processes.html#replication",
    "relUrl": "/design/processes/asynchronous-processes.html#replication"
  },"9": {
    "doc": "Asynchronous processes",
    "title": "Revision management",
    "content": "Yoda supports revision management of data objects, so that users can recover older versions of files. Old revisions are removed regularly using a revision strategy. Both revision creation and revision cleanup are handled asynchronously. Revision creation job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/async-data-revision.py | . | Purpose | create revisions of data objects | . | Lock file | /tmp/irods-async-data-revision.py.lock | . | Scheduling | cronjob, queue based on data object metadata attributes | . | Typically started by | cronjob runs every five minutes | . Data objects are marked for revision creation using a metadata attribute. The default name of these attributes is org_revision_scheduled. The script has a verbose mode (which can be enabled using the -v switch). This will log additional information for troubleshooting to the rodsLog. If a flag data object named /ZONE/yoda/flags/stop_revisions is present, the script will stop processing data objects. Revision cleanup job . |   |   | . | Script | /var/lib/irods/.irods/cronjob-revision-cleanup.sh | . | Purpose | remove unneeded revisions of data objects, as per revision strategy | . | Lock file | no lock file | . | Typically started by | daily cronjob | . ",
    "url": "/yoda/design/processes/asynchronous-processes.html#revision-management",
    "relUrl": "/design/processes/asynchronous-processes.html#revision-management"
  },"10": {
    "doc": "Asynchronous processes",
    "title": "Statistics",
    "content": "The statistics module provides users with an overview of the amount of data stored in Yoda groups and communities. Statistics job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/monthly-storage-statistics.r | . | Purpose | record size of data in group metadata | . | Lock file | no lock file | . | Typically started by | monthly cronjob | . ",
    "url": "/yoda/design/processes/asynchronous-processes.html#statistics",
    "relUrl": "/design/processes/asynchronous-processes.html#statistics"
  },"11": {
    "doc": "Asynchronous processes",
    "title": "Archiving and publication",
    "content": "Asynchronous jobs are also used to copy data packages from a research or intake folder to the vault, as well as to process publications. Retry copy to vault job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/retry-copy-to-vault.r | . | Purpose | copy data packages from research groups to the vault | . | Lock file | no lock file, but collection metadata attribute records processing status | . | Typically started by | cronjob, runs every minute | . By default, groups that are to be copied to the vault are marked with a metadata attribute named cronjob_copy_to_vault. Intake copy to vault job . |   |   | . | Script | /var/lib/irods/.irods/job_movetovault.r | . | Purpose | copy data packages from intake groups to the vault | . | Lock file | uses lock attribute on the vault folder | . | Typically started by | cronjob, runs every five minutes | . Process publication job . |   |   | . | Script | /etc/irods/yoda-ruleset/tools/process-publication.r | . | Purpose | Asynchronously handles publication and depublication of data packages | . | Lock file | no lock file, but status is recorded in metadata | . | Typically started by | cronjob, runs every minute | . ",
    "url": "/yoda/design/processes/asynchronous-processes.html#archiving-and-publication",
    "relUrl": "/design/processes/asynchronous-processes.html#archiving-and-publication"
  },"12": {
    "doc": "Authentication",
    "title": "Authentication",
    "content": " ",
    "url": "/yoda/design/overview/authentication.html",
    "relUrl": "/design/overview/authentication.html"
  },"13": {
    "doc": "Authentication",
    "title": "PAM stack",
    "content": "When creating a session with the iRODS framework the authentication is handled by the Linux PAM (Pluggable Authentication Modules) stack. The PAM stack for Yoda/iRODS can be found on the iCAT server at /etc/pam.d/irods. In this file several modules are defined that check whether the passed credentials constitute a valid authentication. Per module one can specify control values that determine the action that should be taken depending on the result of that module. This way one can let the authentication cascade to following modules if previous ones failed, or signify that a certain module is require to succeed. Please note that any changes to the PAM stack directly may have serious consequences for the security of the Yoda system and should not be necessary. Instead, if you encounter issues with authentication, contact your functional admin for help. Available modules for Yoda . The default PAM stack for Yoda (which is the one for iRODS) has two modules for authentication: . | Local users on the system: pam_unix | Radius server: pam_radius_auth | . Additionally, one can configure two more authentication methods: . | For external users: uses is-user-external.sh and external-auth.py | For authentication via OIDC protocol: oidc.py | For data access passwords: token_auth.py | . For configuring the additional authentication methods, please look at the relevant documentation. Testing . To test the configured PAM stack, you can use the irodsPamAuthCheck tool. This is located on the iRODS server at /usr/sbin/irodsPamAuthCheck. The program requires a username to be passed as a parameter and then prompts for the password. These will then be passed to the PAM stack. If successful, the output will be Authenticated, otherwise the output will be Not Authenticated. ",
    "url": "/yoda/design/overview/authentication.html#pam-stack",
    "relUrl": "/design/overview/authentication.html#pam-stack"
  },"14": {
    "doc": "Authentication",
    "title": "Yoda portal",
    "content": "The Yoda Portal is built on top of iRODS. As such, when logging in to Yoda, an iRODS session has to be created as well. Creation of the iRODS session goes by sending iRODS a PAM Auth Request and is handled as described in the previous section. The authentication mechanism for Yoda is described below. Default login . When clicking the Sign in button in the Yoda Portal, you are taken to user/gate.html. This page has an input field for the username and a button Next to go to the next step. This preliminary login page user/gate.html is there to guide users to the correct authentication method based on their username. By default no redirecting is done based on the username, unless configured otherwise. After clicking Next, the user will be presented with the login page user/login.html with an additional input for the user password and a Login button. Additionally there might be an extra button for OIDC login, which will be discussed shortly. Note that after giving a username on user/gate.html this username is automatically filled in on the login page and can be modified. If the username is modified to a different username which, according to configuration, should be redirected to a different login page, this will now happen at the moment the user clicks the Login button. This way it is possible to force specific authentication methods for specific users. For example, it has been built with OIDC login in mind for usernames that end with a specific domain that is configurable. OpenID Connect (OIDC) . When configured, it is possible to login into Yoda using OIDC. The authentication flow is best explained via a diagram: . The above diagram shows the happy flow: no errors occur at any point during the flow. As the login start with a request to Yoda, any errors should always end up at Yoda so that a sensible error message can be shown to the user. ",
    "url": "/yoda/design/overview/authentication.html#yoda-portal",
    "relUrl": "/design/overview/authentication.html#yoda-portal"
  },"15": {
    "doc": "Authentication",
    "title": "Data Access Passwords",
    "content": "Data Access Passwords are one-time passwords for data-access through iCommands and webDAV. To get a Data Access Password you must login in the portal. After logging in, click on your username at the top-right corner to open a drop-down menu, and select Data Access Password. On this page you can generate Data Access Passwords for your account. The passwords are valid for 72 hours. If the password has expired, you can simply repeat this procedure. ",
    "url": "/yoda/design/overview/authentication.html#data-access-passwords",
    "relUrl": "/design/overview/authentication.html#data-access-passwords"
  },"16": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Configuring cleanup functionality of temporary files",
    "content": "This page contains instructions for configuring the cleanup feature in the research module. This feature helps users find and remove files that should not be archived or published. ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#configuring-cleanup-functionality-of-temporary-files",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#configuring-cleanup-functionality-of-temporary-files"
  },"17": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Background",
    "content": "Some software automatically creates temporary, cache or metadata files. For example, Windows Explorer can automatically create Windows thumbnail cache files that contain cached thumbnails of images. Such files should typically not be archived or published. Removing these files manually is cumbersome, so Yoda has a cleanup tool that enables users to find these files easily and optionally remove them. Yoda searches for these files using a set of filename selection masks, such as wildcards. The selection masks are configured at a system-wide level by the system administrator. ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#background",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#background"
  },"18": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Defining selection masks",
    "content": "Selection masks are used to match a type of file by its name. Mask - find specific files . It is possible to search for files that have a specific name. For example: . mask definition: 'Thumbs.db' . This mask will match files named ‘Thumbs.db’. Mask - use of wildcards . It is possible to use all common wildcards in the creation of a mask. For example: . mask definition using wildcard: '.*'' . This mask will match files with a name starting with ‘.’. Multiple masks . Masks can be concatenated with a comma. For example: . multiple masks in mask definition: '.*','Thumbs.db' . ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#defining-selection-masks",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#defining-selection-masks"
  },"19": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Configuring the variable",
    "content": "When creating a new Yoda instance, set variable ‘temporary_files’ in the group_vars, as explained in Configuring Yoda and run the playbook. ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#configuring-the-variable",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#configuring-the-variable"
  },"20": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Default selection masks",
    "content": "By default, Yoda uses these selection masks: . | ‘._*’ # MacOS resource fork | ‘.DS_Store’ # MacOS custom folder attributes | ‘Thumbs.db’ # Windows thumbnail images | . ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#default-selection-masks",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#default-selection-masks"
  },"21": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Usage",
    "content": "In the research space action menu in the Yoda portal, select the option ‘Cleanup temporary files’. ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html#usage",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html#usage"
  },"22": {
    "doc": "Configuring cleanup functionality temporary files",
    "title": "Configuring cleanup functionality temporary files",
    "content": " ",
    "url": "/yoda/administration/configuring-cleanup-temporary-files.html",
    "relUrl": "/administration/configuring-cleanup-temporary-files.html"
  },"23": {
    "doc": "Configuring Data Access Passwords",
    "title": "Configuring Data Access Passwords",
    "content": "Instruction on how to configure Data Access Passwords. ",
    "url": "/yoda/administration/configuring-data-access-passwords.html",
    "relUrl": "/administration/configuring-data-access-passwords.html"
  },"24": {
    "doc": "Configuring Data Access Passwords",
    "title": "Configuring the variables",
    "content": "When creating a new Yoda instance, setup the variables in the group_vars as explained in Configuring Yoda and run the playbook. Alternatively, you can choose to pass the variables with the –extra-vars option every time when running the Ansible playbook. The development group_vars contains examples for all of the variables. For Data Access Passwords to function properly it requires the following variables to be set: . | enable_tokens (default: false), used by Ansible during setup. | token_database_password, used as password for the token database. | . For customization purposes, you can also configure: . | token_database | token_length | token_lifetime | . ",
    "url": "/yoda/administration/configuring-data-access-passwords.html#configuring-the-variables",
    "relUrl": "/administration/configuring-data-access-passwords.html#configuring-the-variables"
  },"25": {
    "doc": "Configuring OIDC",
    "title": "Configuring OpenID Connect (OIDC)",
    "content": "Instruction on how to configure OpenID Connect authentication. ",
    "url": "/yoda/administration/configuring-openidc.html#configuring-openid-connect-oidc",
    "relUrl": "/administration/configuring-openidc.html#configuring-openid-connect-oidc"
  },"26": {
    "doc": "Configuring OIDC",
    "title": "Configuring the variables",
    "content": "When creating a new Yoda instance, setup the variables in the group_vars as explained in Configuring Yoda and run the playbook. Alternatively, you can choose to pass the variables with the –extra-vars option every time when running the Ansible playbook. The development group_vars contains examples for all of the variables. For OIDC to function properly it requires the following variables to be set: . | oidc_active (default: false), used by Ansible during setup. Please note that switching oidc_active to false (and running the Ansible playbook again) is not a safe way to disable OIDC: you should also replace the oidc_client_id and oidc_client_secret values with placeholders. | oidc_client_id | oidc_client_secret | oidc_auth_base_uri | oidc_token_uri | oidc_userinfo_uri | oidc_jwks_uri, which returns all the valid JSON Web Key sets | oidc_jwt_issuer, the iss value in the JWT token | . Additionally, depending on the authorization server, you may need to configure the following variables: . | oidc_scopes (default: openid) | oidc_acr_values | oidc_email_field (default: email) | oidc_login_hint (default: true) | . Finally, for customization purposes, you can also configure: . | oidc_domains, which should be an array of domains with OIDC authentication, e.g. [\"mydomain.com\",\"myotherdomain.com\"]. By default, OIDC authentication is enabled for every domain (provided that oidc_active is set to true) | oidc_signin_text (deprecated since v1.8) | . For token verification there are also the following parameters which define what checks are done when verifying a JWT. Take caution when setting values to false, as this makes verification less strict. Details can be found in the group_vars file. | oidc_req_exp (default: true) | oidc_req_iat (default: false) | oidc_req_nbf (default: false) | oidc_verify_aud (default: true) | oidc_verify_iat (default: false) | oidc_verify_exp (default: true) | oidc_verify_iss (default: true) | . ",
    "url": "/yoda/administration/configuring-openidc.html#configuring-the-variables",
    "relUrl": "/administration/configuring-openidc.html#configuring-the-variables"
  },"27": {
    "doc": "Configuring OIDC",
    "title": "Verifying OIDC",
    "content": "To verify whether the deployment/update went successfully, go to the Yoda portal and click the Sign in button, enter an email address and click Next. If configured correctly, you should now see an extra button with the text as configured with the oidc_signin_text variable (default: Sign in with OIDC). When clicking on the Sign in with OIDC button, login at the configured authorized server and verify that you are returned to the Yoda portal homepage. If so, you have correctly configured authentication via OIDC. Please also verify that the standard login method is still working as intended. Alternatively, if you have configured the oidc_domains parameter, entering an email address with the configured domain and clicking Next should redirect you automatically to the configured authorization server. Follow the above steps as if having clicked the Sign in with OIDC button . ",
    "url": "/yoda/administration/configuring-openidc.html#verifying-oidc",
    "relUrl": "/administration/configuring-openidc.html#verifying-oidc"
  },"28": {
    "doc": "Configuring OIDC",
    "title": "Troubleshooting",
    "content": ". | The Sign in with OIDC button is missing: check if the oidc_active variable is set to true in you group_vars and run the Ansible playbook again. | After signing in at the authorization server I am redirected to the login screen with the error 'Failed to login to Yoda. Please contact a data manager about your account.': This can have multiple causes: . | The user that is trying to sign in does not exist, or | An error occurred after signing in at the authorization server. | . To check whether the problem is caused by case 1, verify that the user exists in Yoda and add them if they are not. To solve case 2, re-check the client secret, the token URI, the email field, the public key, and scopes variables. | . ",
    "url": "/yoda/administration/configuring-openidc.html#troubleshooting",
    "relUrl": "/administration/configuring-openidc.html#troubleshooting"
  },"29": {
    "doc": "Configuring OIDC",
    "title": "Configuring OIDC",
    "content": " ",
    "url": "/yoda/administration/configuring-openidc.html",
    "relUrl": "/administration/configuring-openidc.html"
  },"30": {
    "doc": "Configuring Yoda",
    "title": "Configuring Yoda",
    "content": "Instructions on how to configure a (new) Yoda instance. ",
    "url": "/yoda/administration/configuring-yoda.html",
    "relUrl": "/administration/configuring-yoda.html"
  },"31": {
    "doc": "Configuring Yoda",
    "title": "1. Create new environment",
    "content": "This first step is optional. You can configure a (new) Yoda instance in an existing environment or create a new environment. A development environment is available with two example instances. To create a new environment make a new directory under environments. For example a production environment: . mkdir environments/production . We call our new instance ‘yoda’, so create a new instance directory: . mkdir environments/production/yoda . In this new instance directory two directories are needed, on for the Yoda instance variables (group_vars) and one for host specific variables (host_vars). mkdir environments/production/yoda/group_vars mkdir environments/production/yoda/host_vars . ",
    "url": "/yoda/administration/configuring-yoda.html#1-create-new-environment",
    "relUrl": "/administration/configuring-yoda.html#1-create-new-environment"
  },"32": {
    "doc": "Configuring Yoda",
    "title": "2. Add hosts of new Yoda instance",
    "content": "Hosts of a Yoda instance are defined in the Ansible inventory file ‘hosts’. For the development instance ‘full’ this inventory can be found in environments/development/full/hosts. In the inventory the hosts of an instance are defined, their functional roles and to which groups they belong. Example configuration defining the and functional roles of an instance called ‘yoda’: . [yoda:children] yoda_portal yoda_database yoda_icat yoda_resource yoda_public yoda_eus [yoda_portal] host1.yoda.test # leave this out when using an existing database for ICAT [yoda_database] host1.yoda.test [yoda_icat] host1.yoda.test [yoda_resource] host2.yoda.test [yoda_public] host3.yoda.test [yoda_eus] host4.yoda.test . Add the new functional roles of the instance to the corresponding groups. For example: . [portals:children] yoda_portal # leave this out when using an existing database for ICAT [databases:children] yoda_database [icats:children] yoda_icat [resources:children] yoda_resource [publics:children] yoda_public [eus:children] yoda_eus . It is possible to deploy davrods to a separate host by adding a davrods host and group: . [yoda:children] yoda_portal yoda_davrods yoda_database yoda_icat yoda_resource yoda_public yoda_eus [yoda_davrods] host5.yoda.test [davrods:children] yoda_davrods . Last step to add the hosts of a new Yoda instance is to create configuration files for every new host. In development environment these configuration files are placed in environments/development/hosts. For example, for host ‘host1.yoda.test’ a configuration file is created: . touch environments/development/host_vars/host1.yoda.test . And place the basic host configuration in the new file: . --- ansible_host: host1.yoda.test . ",
    "url": "/yoda/administration/configuring-yoda.html#2-add-hosts-of-new-yoda-instance",
    "relUrl": "/administration/configuring-yoda.html#2-add-hosts-of-new-yoda-instance"
  },"33": {
    "doc": "Configuring Yoda",
    "title": "3. Configure (new) Yoda instance",
    "content": "To configure a (new) Yoda instance we have to edit the instance configuration in the Yoda instance variables directory (group_vars). In case of a new Yoda instance we can copy a configuration of a full development (environments/development/full/) instance as base. The configuration is split in several parts. Below an overview of these parts and the configuration options available. Ansible configuration . | Variable | Description | . | ansible_user | Administrative user on instance for Ansible | . | ansible_ssh_private_key_file | Path to private key file of administrative user | . | repo_only | Only download packages from repos | . Note: if one of these variables are different for a host then define them in the corresponding host specific variables file (host_vars). Yoda configuration . | Variable | Description | . | instance | Name of Yoda instance, as defined in hosts file | . | yoda_version | Yoda version. Use a git branch (e.g. release-1.8) or a tag (e.g. v1.8.5) | . | yoda_environment | Yoda environment: development, testing, acceptance or production | . | yoda_portal_fqdn | Yoda Portal fully qualified domain name (FQDN) | . | yoda_davrods_fqdn | Yoda Davrods WebDAV fully qualified domain name (FQDN) | . | yoda_davrods_anonymous_fqdn | Yoda Davrods anonymous WebDAV fully qualified domain name (FQDN) | . | yoda_davrods_logo_path | Path of the DavRODS logo on the portal. Defaults to the themed logo. | . | yoda_davrods_logo_link | URL that the DavRODS logo is linked to (default: https://www.uu.nl) | . | yoda_enable_httpd | Whether to enable the httpd service (boolean, default value: true). Set to false if manual actions are needed before starting the web server (e.g. mounting encrypted volumes) | . | httpd_log_forwarded_for | Whether to log X-Forwarded-For headers in Apache logs (boolean, default value: false). This logs source IP addresses of requests if requests to the Yoda web portal and/or WebDAV interface are routed via a load balancer. | . | tcp_keepalive_time | IPv4 TCP keepalives: time until first keepalive (kernel parameter). Can be useful to tune in order to prevent timeouts on long transfers. | . | tcp_keepalive_intvl | IPv4 TCP keepalives: time between keepalives (kernel parameter). Can be useful to tune in order to prevent timeouts on long transfers. | . iRODS configuration . | Variable | Description | . | irods_admin | iRODS admin username | . | irods_password | iRODS admin password | . | irods_database_user | The iRODS database username | . | irods_database_password | The password for the iRODS database username | . | irods_database_enable_yoda_indexes | Enable indexes to speed up Yoda search operations (default: false). This is mainly useful for medium-sized and large environments (millions of data objects or more). Please note that the indexes can take up a significant amount of diskspace (rough estimate: 10-30% increase in database size). They will be created asynchronously. This can take some time on existing environments with a significant amount of data, and temporarily decrease performance. | . | irods_zone | The name of the iRODS Zone | . | irods_icat_fqdn | iRODS iCAT fully qualified domain name (FQDN) | . | irods_database_fqdn | iRODS database fully qualified domain name (FQDN) | . | irods_resource_fqdn | iRODS resource fully qualified domain name (FQDN). Don’t define this variable if you have multiple resource servers. | . | irods_default_resc | iRODS default resource name | . | irods_resc_trigger_pol | List of text patterns for matching non-primary resources where changes also need to trigger policies (e.g. asynchronous replication). Example: [“^testResc$”,”^myResc$”] | . | irods_ssl_verify_server | Verify TLS certificate, use ‘cert’ for acceptance and production | . | irods_resources | Definition of iRODS resources of this Yoda instance | . | irods_service_type | Possible values: ‘sysv’ (System V) or ‘systemd’ | . | irods_max_open_files | Maximum number of open files for iRODS service (only effective when irods_service_type is set to ‘systemd’) | . | irods_enable_service | Whether to enable the iRODS service. Set to false if manual actions are needed before starting iRODS, e.g. mounting encrypted volumes (only effective when irods_service_type is set to ‘systemd’) | . | irods_rum_job_enabled | Whether to enable the daily RUM job for removing unused metadata entries (default: true) | . | irods_rum_job_hour | Time to run RUM job - hour (default: 20) | . | irods_rum_job_minute | Time to run RUM job - minute (default: 0) | . S3 configuration - for iRODS S3 resource plugin and s3cmd utilities . | Variable | Description | . | enable_s3_resource | Enable iRODS S3 Resource Plugin. Default: false | . | s3_access_key | S3 access key of S3 buckets (used by s3cmd, and optionally by S3 resource plugin, if S3 resource context points to .s3auth file) | . | s3_secret_key | S3 secret key of S3 buckets (used by s3cmd, and optionally by S3 resource plugin, if S3 resource context points to .s3auth file) | . | s3_hostname | S3 server hostname (used by s3cmd; the hostname used by the S3 resource plugin is configured in the S3 resource contexts instead) | . Research module configuration . | Variable | Description | . | default_yoda_schema | Default Yoda XML scheme: default-0 or default-1 | . | enable_revisions | Enable revisions: yes (1) or no (0) | . | enable_revision_cleanup | Enable cleanup job for removing old revisions (true/false, default: true) | . | enable_async_replication | Enable asynchronous replication cronjob: yes (1) or no (0) | . | revision_strategy | Revision strategy: A, B, J or Simple | . | yoda_random_id_length | Length of random ID to add to persistent identifier | . | yoda_prefix | Prefix for internal portion of persistent identifier | . | update_rulesets | Update already installed rulesets with git | . | override_resc_install_rulesets | Install rulesets on server even if it is a resource server (default: false). This override parameter can be used on resource servers that have an additional role, e.g. DavRODS server | . | update_schemas | Update already installed schemas, formelements and stylesheets: yes (1) or no (0) | . | credential_files | Location of Yoda credentials files | . | temporary_files | List of temporary files for cleanup functionality | . | metadata_schemas | List of metadata schemas to install on the system | . Deposit module configuration . | Variable | Description | . | enable_deposit | Enable deposit module | . Intake module configuration . | Variable | Description | . | enable_intake | Enable intake module | . | intake_groups | List of intake groups (without the “grp-intake-“ prefix) | . Datarequest module configuration . | Variable | Description | . | enable_datarequest | Enable datarequest module | . | datarequest_help_contact_name | Help contact name | . | datarequest_help_contact_email | Help contact email address | . OpenSearch configuration . | Variable | Description | . | enable_open_search | Enable OpenSearch and indexing plugin | . | opensearch_server | FQDN of the OpenSearch server (typically the provider) | . Yoda notifications configuration . | Variable | Description | . | send_notifications | Enable notifications: yes (1) or no (0) | . | notifications_sender_email | Notifiations sender email address | . | notifications_reply_to | Notifiations Reply-To email address | . Yoda internal SMTP settings configuration . | Variable | Description | . | smtp_server | SMTP server to send mail to | . | smtp_username | SMTP server username | . | smtp_password | SMTP server password | . | smtp_auth | Whether to use SMTP authentication (true/false, default: true) | . | smtp_starttls | Whether to force StartTLS on non-SMTP connections (true/false, default: true) | . PostgreSQL database configuration . | Variable | Description | . | postgresql_max_connections | Maximum number of database connections (default: 100) | . | postgresql_shared_buffers | Amount of memory database should use for shared buffers. Rule of thumb: set to 25% of memory on dedicated database server; on a shared server, it should probably be lower. Default value: 32 MB. | . | postgresql_work_mem | Maximum amount of worker memory. Rule of thumb: increasing worker memory can help with improving performance, but it is necessary to ensure that sufficient memory is available, considering the maximum number of database connections. Default value: 1 MB. | . | postgresql_maintenance_work_mem | Maximum amount of memory for maintenance processes, such as VACUUM. Default value: 16 MB. | . | postgresql_effective_cache_size | Tells the query planner how much memory it can expect to be available for disk caching for the database. Rule of thumb: set to approximately 50-75% on dedicated database server. Default value: 128 MB. | . | postgresql_random_page_cost | Tells the query planner about the relative cost of random access versus sequential access. You could use a tool like fio to get an estimate, or use a ballpark estimate based on the type of storage of the database volume (e.g. 1.0 for SSD-based storage). Default value is 4.0. | . | postgresql_log_line_prefix: | Format of log message prefix in the PostgreSQL log, for adding timestamps etc. to log messages. The default value adds a timestamp and process number, which is sufficient for most purposes. It might be useful to log additional information in specific situations, such as when troubleshooting database issues. | . | postgresql_log_min_duration_statement | Minimum number of milliseconds for slow query logging (default: -1 / disabled) | . | postgresql_log_autovacuum_min_duration | Minimum number of milliseconds for logging slow autovacuum actions (default: -1 / disabled) | . | postgresql_timezone | Timezone that PostgreSQL uses. Defaults to Europe/Amsterdam. | . Postfix configuration . | Variable | Description | . | enable_postfix | Whether to enable the Postfix local MTA (default: false) | . | postfix_myhostname | Hostname of server where Postfix will be installed (compulsory parameter if Postfix is enabled) | . | postfix_relayhost | Relay host, the server that Postfix should send emails to (compulsory parameter if Postfix is enabled) | . | postfix_relayhost_port: | Port of relay host (default: 587) | . | postfix_relayhost_username | User name for authentication on relay host (compulsory parameter if Postfix is enabled) | . | postfix_relayhost_password | Password for authentication on relay host (compulsory parameter if Postfix is enabled) | . | postfix_smtp_enable_tls | Whether to enable TLS on connections to relay host. This also enables authentication on connections to the relay host (default: true) | . | postfix_enable_debugging | This enables additional logging on connections to the relay host. Useful for troubleshooting. (default: false) | . | postfix_myorigin | Sets origin domain for emails sent on the system. Defaults to the postfix_myhostname domain. | . | postfix_inet_protocols | Refers to Postfix inet_protocols setting. Can be useful for running Postfix in IPv4 only mode, if no IPv6 connectivity is available (default: “all”) | . DataCite Configuration . | Variable | Description | . | datacite_username | DataCite username | . | datacite_password | DataCite password | . | datacite_prefix | DataCite DOI prefix | . | datacite_rest_api_url | DataCite REST API URL | . EPIC PID Configuration . | Variable | Description | . | epic_url | EPIC PID server URI (undefined disables EPIC PID) | . | epic_handle_prefix | EPIC PID prefix | . | epic_key | EPIC PID key (base64 encoded) | . | epic_cert | EPIC PID cert (base64 encoded) | . Data Access Tokens configuration . | Variable | Description | . | enable_tokens | Boolean indicating if Data Access Tokens for webDAV and iCommands are enabled. Must be true or false | . | token_database | Location of the database that contain the tokens | . | token_database_password | Token database password | . | token_length | Length of data access tokens | . | token_lifetime | Lifetime of data access tokens (in hours) | . | token_expiration_notification | Send notification before token expiration (in hours) | . | enable_radius_fallback | Fall back on RADIUS authentication if token authentication fails (default: false). Only enables RADIUS fallback if enable_tokens is set to true.This is a legacy parameter that will be removed in a future version of Yoda. | . Public host configuration . | Variable | Description | . | yoda_public_host | Yoda public host | . | yoda_public_fqdn | Yoda public fully qualified domain name (FQDN) | . | upload_priv_key | Yoda public upload private key (base64 encoded) | . | upload_pub_key | Yoda public upload public key (base64 encoded) | . External user service configuration . | Variable | Description | . | yoda_eus_fqdn | Yoda External User Service fully qualified domain name (FQDN) | . | eus_api_fqdn | External User Service API fully qualified domain name (FQDN) | . | eus_api_port | External User Service API port | . | eus_api_secret | External User Service API secret | . | eus_db_password | External User Service database password | . | eus_smtp_host | External User Service SMTP host | . | eus_smtp_port | External User Service SMTP port | . | eus_smtp_user | External User Service SMTP user | . | eus_smtp_password | External User Service SMTP password | . | eus_smtp_auth | External User Service SMTP authentication (true/false, default: true) | . | eus_smtp_security | External User Service SMTP encryption (tls/ssl/false, default: tls) | . | eus_smtp_from_address | External User Service from address | . | eus_smtp_replyto_address | External User Service replyto address | . | eus_mail_template | External User Service mail template | . OpenID Connect (OIDC) configuration . | Variable | Description | . | oidc_active | Boolean indicating whether OpenId Connect with the following parameters is enabled of not. Must be true or false | . | oidc_domains | Domains that should use OIDC (list). If this parameter is set, the first domain in the list is also used to generate the user name placeholder on the portal gate and login pages. | . | oidc_client_id | OIDC Client Id | . | oidc_client_secret | OIDC Client Secret/Password | . | oidc_callback_url | OIDC Callback url | . | oidc_auth_base_uri | OIDC Authorization URI without parameters | . | oidc_login_hint | Boolean indicating whether login hint should be added to Authorization URI (default: True) | . | oidc_token_uri | OIDC Token URI | . | oidc_userinfo_uri | OIDC Userinfo URI | . | oidc_scopes | OIDC Scopes | . | oidc_acr_values | OIDC Authentication Context Class Reference Values | . | oidc_email_field | The identifier of the JSON field in the id_token containing the email address. Default: email the email address (default: email) | . | oidc_jwks_uri | The url where the JWKS can be found (Java web key sets) | . | oidc_jwt_issuer | The issuer of the JWT tokens (‘iss’ value in JWT, for verification) | . | oidc_req_exp | Check that exp (expiration) claim is present | . | oidc_req_iat | Check that iat (issued at) claim is present | . | oidc_req_nbf | Check that nbf (not before) claim is present | . | oidc_verify_aud | Check that aud (audience) claim matches audience | . | oidc_verify_iat | Check that iat (issued at) claim value is an integer | . | oidc_verify_exp | Check that exp (expiration) claim value is OK | . | oidc_verify_iss | Check that iss (issue) claim is as expected | . Mailpit configuration . | Variable | Description | . | enable_mailpit | Enable Mailpit for email testing. Should only be enabled on local development environments for security reasons. Mailpit and Postfix shouldn’t be enabled simultaneously. Default: false | . | mailpit_version | Mailpit version to install | . | mailpit_max_messages | Maximum number of messages to store (default: 10000) | . | mailpit_smtp_bind_address | Address to bind on for SMTP interface (default: 0.0.0.0) | . | mailpit_smtp_port | TCP port for SMTP interface (default: 25) | . Tooling . | Variable | Description | . | enable_irods_consistency_check | Install iRODS consistency checker tool (ichk) | . | irods_consistency_check_version | iRODS consistency checker (ichk) version | . | enable_icat_database_checker | Install iCAT database checker | . | icat_database_checker_version | iCAT database checker version | . ",
    "url": "/yoda/administration/configuring-yoda.html#3-configure-new-yoda-instance",
    "relUrl": "/administration/configuring-yoda.html#3-configure-new-yoda-instance"
  },"34": {
    "doc": "DANS sword2.0 interface",
    "title": "DANS sword2.0 interface",
    "content": " ",
    "url": "/yoda/design/other/dans-sword2.html",
    "relUrl": "/design/other/dans-sword2.html"
  },"35": {
    "doc": "DANS sword2.0 interface",
    "title": "Description",
    "content": "The interface uses a bag holding all data and corresponding metadata of research to be deposited at DANS. See below for description of a ‘bag’. The bag is posted to DANS using a SWORD-client. Yoda uses: https://github.com/swordapp/python-client-sword2/wiki/Quickstart . After posting, a response is received holding a URL that must be used in order to receive that processing status of the deposit process. ",
    "url": "/yoda/design/other/dans-sword2.html#description",
    "relUrl": "/design/other/dans-sword2.html#description"
  },"36": {
    "doc": "DANS sword2.0 interface",
    "title": "‘statement’ URI",
    "content": "https://act.easy.dans.knaw.nl/sword2/statement/09af7269-2b77-458d-99c2-651be6fb3435 . This URI is received when depositing. The response holds the reference to the processing status of the deposit. ",
    "url": "/yoda/design/other/dans-sword2.html#statement-uri",
    "relUrl": "/design/other/dans-sword2.html#statement-uri"
  },"37": {
    "doc": "DANS sword2.0 interface",
    "title": "Statuses",
    "content": "DRAFT – a bag can be sent in multiple phases (continued deposit) and this is the state when the last part is not received yet SUBMITTED – deposit is in queue to be processed INVALID – bag that was sent is not valid (technically). REJECTED – bag that was sent is not according to rules set by DANS FAILED – technical error by DANS ARCHIVED – deposit is complete and accepted. The data is archived . ",
    "url": "/yoda/design/other/dans-sword2.html#statuses",
    "relUrl": "/design/other/dans-sword2.html#statuses"
  },"38": {
    "doc": "DANS sword2.0 interface",
    "title": "Process statuses and DOI",
    "content": "Het is de bedoeling dat jullie af en toe de statement URL aanroepen om te kijken wat de status van de deposit is. Is die SUBMITTED, probeer het dan later nog eens (wanneer het druk is, kan de wachtrij soms behoorlijk oplopen waardoor het langer duurt om de data te verwerken). Wanneer deze ARCHIVED is, ben je klaar. Eventueel haal je dan nog wat informatie uit de XML, zoals de URL naar EASY (body van ) of de **DOI** (href attribute in | ). ",
    "url": "/yoda/design/other/dans-sword2.html#process-statuses-and-doi",
    "relUrl": "/design/other/dans-sword2.html#process-statuses-and-doi"
  },"39": {
    "doc": "DANS sword2.0 interface",
    "title": "Error statuses",
    "content": "Wanneer je INVALID of REJECTED tegenkomt, hebben jullie zelf iets fout gedaan. Over het algemeen proberen we deze foutmeldingen zo duidelijk mogelijk op te schrijven, maar als je iets tegen komt wat niet duidelijk is, dan horen we dat natuurlijk graag! Bij een FAILED deposit is er aan onze kant iets niet goed gegaan. Dit kan bijv. een omgevallen service of een bug in de applicatie zijn. We proberen deze uiteraard z.s.m. op te losse . ",
    "url": "/yoda/design/other/dans-sword2.html#error-statuses",
    "relUrl": "/design/other/dans-sword2.html#error-statuses"
  },"40": {
    "doc": "DANS sword2.0 interface",
    "title": "Bag description",
    "content": "A bag must contain the following items: package name   /data        .. actual data package data   /metadata       dataset.xml       files.xml - declaration of files in /data folder   bag-info.txt   bagit.txt   manifest-sha1.txt   tagmanifest-md5.txt . bag-info.txt . Payload-Oxum: 3212743.5 Bagging-Date: 2018-04-13 Bag-Size: 3.1 MB Created: 2016-11-12T23:41:11.000+00:00 . bagit.txt . BagIt-Version: 0.97 Tag-File-Character-Encoding: UTF-8 . manifest-sha1.txt . Describes all files in data folder including each sha1. f50380cd3a4ae5b8ea3d524a4b1e8582eca50893 data/README.md 0a66ea77834e337e28a043db6d6f3d745c944593 data/random-images/image03.jpeg f100629544e98ad21503b04a276fe6185cb4e9d2 data/random-images/image01.png f750a66151421a62521be6495684fb8384cb4aa0 data/a/deeper/path/With-some-file.txt 4ae4fb20ee161b8026a468160553e623dcea4914 data/random-images/image02.jpeg . tagmanifest-md5.txt . 0162e3bed9af9459d68241cf235281b8    bag-info.txt 9e5ad981e0d29adc278f6a294b8c2aca    bagit.txt e5811f26340bf1a74a866c9f4825384e    metadata/dataset.xml 8beffb1f328ff9227f1f862ecb1ff4e6    metadata/files.xml 1ee7172e6a9991bde1e7d381f37e7747    manifest-sha1.txt . Code example (just testing possibilities - to be elaborated): . from sword2 import Connection SD_URI = 'https://act.easy.dans.knaw.nl/sword2/collection/1' from sword2 import sword2_logging print('hallo') c = Connection(SD_URI, user_name = \"yodatest\", user_pass=\"y$6]AQ5$BZ\\Z\") print('hallo-1') # upload \"package.zip\" to this collection as a new (binary) resource: with open(\"package.zip\", \"r\") as pkg: print('hallo-2') receipt = c.create(col_iri = SD_URI, payload = pkg, mimetype = \"application/zip\", filename = \"package.zip\", packaging = 'http://purl.org/net/sword/package/Binary', in_progress = False) # As the deposit isn't yet finished print('++++++++++++++++++++++++++') print(receipt) print('se iri=' + receipt.se_iri) print('media iri=' + receipt.edit_media) print('edit iri=' + receipt.edit) print('##################') print(receipt.links) print('#########') print(receipt.links['http://purl.org/net/sword/terms/statement'][0]['href']) statementURI = receipt.links['http://purl.org/net/sword/terms/statement'][0]['href'] #print(receipt.content) print('**************************') c2 = Connection(statementURI, user_name = \"yodatest\", user_pass=\"y$6]AQ5$BZ\\Z\") resp = c2.get_resource(statementURI) print(resp) print(':::::::::::::::::::::::::') print(resp.response_headers) print(':::::::::::::::::::::::::') print(resp.content) print(':::::::::::::::::::::::::') print(resp.code) print('--------------------------') exit() . ",
    "url": "/yoda/design/other/dans-sword2.html#bag-description",
    "relUrl": "/design/other/dans-sword2.html#bag-description"
  },"41": {
    "doc": "Data requests module",
    "title": "Data requests module",
    "content": " ",
    "url": "/yoda/design/overview/data-requests.html",
    "relUrl": "/design/overview/data-requests.html"
  },"42": {
    "doc": "Data requests module",
    "title": "Introduction",
    "content": "This technical design document describes an approach to implementing support for the submission, review and approval of requests to obtain research data stored in Yoda. ",
    "url": "/yoda/design/overview/data-requests.html#introduction",
    "relUrl": "/design/overview/data-requests.html#introduction"
  },"43": {
    "doc": "Data requests module",
    "title": "Definitions",
    "content": ". | Research group A group of researchers belonging to a particular research lab or otherwise collaborating on a common research goal. E.g. the Brain Morphology Lab. | . ",
    "url": "/yoda/design/overview/data-requests.html#definitions",
    "relUrl": "/design/overview/data-requests.html#definitions"
  },"44": {
    "doc": "Data requests module",
    "title": "Functional description",
    "content": "The supported workflows are described in this section. A sequence diagram mapping the workflow is shown below. Submission of data requests . A researcher seeking to obtain research data stored in Yoda must be able to submit a request for this data. The request must belong to a research proposal, which is submitted along with the data request. The research proposal must describe the purpose for which the researcher wants to obtain the requested data. Management and review of data requests . A delegate of a research programme’s or study’s project manager must be able to perform a cursory preliminary review of a data request. Likewise, a data manager assigned as a custodian of (certain) data stored in Yoda must be also able to submit a review of a data request. After these preliminary reviews, a project manager must be able to assign a data request for review to one or more members of a Data Access Committee (DAC) . The DAC member(s) must be able to review research proposals assigned to him. Final evaluation of research proposals . A project manager must be able to give a final evaluation of a research proposal based on the reviews by the data manager and the DAC member(s), thereby approving or rejecting the data request. Creation of data transfer agreements (DTAs) . Once a data request and its accompanying research proposal have been approved, the data manager must be able to create a DTA specifying the terms and conditions under which the requested data is made available to the requesting researcher. Approval of DTAs . Once a DTA has been created, the requesting researcher must be able to view the DTA and register his agreement to the terms and conditions specified therein. Release of requested data . After the DTA has been signed by the requesting researcher, the data manager may release the requested data to him. The means by which the data is transferred to the researcher is outside of the scope of the data request module. ",
    "url": "/yoda/design/overview/data-requests.html#functional-description",
    "relUrl": "/design/overview/data-requests.html#functional-description"
  },"45": {
    "doc": "Data requests module",
    "title": "Technical description",
    "content": "To keep the complexity of the module to a minimum, existing Yoda functionality and modules are used to implement the functional requirements. Submission of data requests . To allow anyone, including newly registered Yoda users, to submit a data request, a public iRODS collection (named, for example, “datarequests”) must be created. When a data request is submitted through a web form by a researcher, a subcollection is created which will act as a folder for all files related to the research proposal. The data request and research proposal is then saved to this subcollection as a JSON-formatted file. Because researchers only have ownership of subcollections they themselves have created, they cannot access data requests by other researchers. Management and review of data requests . Project managers and data managers must be able to view all submitted data requests. They are enabled to do so by membership of a group (e.g. “brainmorphlab-datamanagers”; see Group Manager) that has group manager permissions on the public collection mentioned above (these include read and write permissions). Because these permissions are recursive, they also apply to the subcollections made by researchers. Upon assignment of a research proposal for evaluation to a DAC member, the DAC member is granted read and write permissions on the subcollection in which the research proposal is stored. DAC membership is determined by membership of a particular group (e.g. “brainmorphlab-dac”), acting as a pool from which the data manager may pick an appropriate member. A DAC member can evaluate a research proposal through a web form. The evaluation is saved as a JSON-formatted file in the subcollection that also holds the research proposal itself. Because multiple research groups may use a Yoda instance, multiple data manager and DAC groups may be created so that data requests meant for data of a particular research group can be handled by data managers associated with that research group. Final evaluation of research proposals . Project managers also belong to a particular group (e.g. “brainmorphlab-pm”. They have the same rights as those in the data manager group, thus allowing them to view the research proposal and associated reviews. A project manager can approve a research proposal through a web form that sets the value of the status AVU of the research proposal subcollection to “approved”. Creation of DTAs . After the data request has been approved, the data manager creates a DTA and adds it as a PDF file to the subcollection (through a web form). The researcher will receive a request to upload as signed copy of this document. Approval of DTAs . The DTA created by the data manager is made available to the researcher. Once the researcher has created a signed copy of the document, he can upload it through a web form. The signed copy is saved in the subcollection. The data may now be made available to the researcher by the data manager. ",
    "url": "/yoda/design/overview/data-requests.html#technical-description",
    "relUrl": "/design/overview/data-requests.html#technical-description"
  },"46": {
    "doc": "Data Package Reference",
    "title": "Data Package Reference",
    "content": "The Data Package Reference is available from the moment the a Data Package has been submitted into the Vault Space This reference can be used to communicate with other users and refer to the Data Package and making references to existing Data Packages, when archiving a new Data Package. The reference is be globally unique and leads to the Vault Space for that Data Package. An example Data Package Reference is yda/2bb04907-97cb-4a35-bc68-b56025bee47e. An example of a complete link to this Data Package would be https://portal.yoda.test/vault/yda/2bb04907-97cb-4a35-bc68-b56025bee47e. ",
    "url": "/yoda/design/overview/data_package_reference.html",
    "relUrl": "/design/overview/data_package_reference.html"
  },"47": {
    "doc": "Data Package Reference",
    "title": "Adding Data Package Reference to existing vault packages",
    "content": "To add the Data Package Reference to existing vault packages without a reference is script is available: . irule -r irods_rule_engine_plugin-python-instance -F /etc/irods/yoda-ruleset/tools/generate-data-package-references.r . ",
    "url": "/yoda/design/overview/data_package_reference.html#adding-data-package-reference-to-existing-vault-packages",
    "relUrl": "/design/overview/data_package_reference.html#adding-data-package-reference-to-existing-vault-packages"
  },"48": {
    "doc": "Deploying Yoda",
    "title": "Deploying Yoda",
    "content": "Instructions needed for deploying a (new) Yoda instance. ",
    "url": "/yoda/administration/deploying-yoda.html",
    "relUrl": "/administration/deploying-yoda.html"
  },"49": {
    "doc": "Deploying Yoda",
    "title": "Deploying new instance",
    "content": "Configure the new instance and run the Yoda playbook to deploy. For example, deploying the instance ‘yoda’ in an environment called ‘production’: . ansible-galaxy collection install -r requirements.yml ansible-playbook -i environments/development playbook.yml --limit=yoda -K . ",
    "url": "/yoda/administration/deploying-yoda.html#deploying-new-instance",
    "relUrl": "/administration/deploying-yoda.html#deploying-new-instance"
  },"50": {
    "doc": "Deploying Yoda",
    "title": "Upgrading existing instance",
    "content": "To upgrade an existing Yoda instance update your Yoda Ansible repository to include the latest changes: . git pull . Install all Ansible collections needed to deploy Yoda: . ansible-galaxy collection install -r requirements.yml . Upgrade the configuration of the Yoda Instance and then run the Yoda playbook: . ansible-playbook -i environments/development/allinone playbook.yml --limit=yoda -K . You may want to run the Yoda playbook in check mode first to see the changes it will make: . ansible-playbook -i environments/development/allinone playbook.yml --limit=yoda -CDK . ",
    "url": "/yoda/administration/deploying-yoda.html#upgrading-existing-instance",
    "relUrl": "/administration/deploying-yoda.html#upgrading-existing-instance"
  },"51": {
    "doc": "Deployment",
    "title": "Deployment",
    "content": " ",
    "url": "/yoda/design/overview/deployment.html",
    "relUrl": "/design/overview/deployment.html"
  },"52": {
    "doc": "Deployment",
    "title": "Ansible Playbook",
    "content": "The master playbook for automated deployment of Yoda can be found in playbook.yml. It consists of four tier which implements four distinct functional roles: . | Yoda webportal | iRODS database | iRODS provider (catalog) server | iRODS consumer (resource) server | . Yoda webportal tier . The Yoda webportal tier provisions the host with the following: . | Apache webserver | Python | iRODS iCommands &amp; runtime | Yoda portal and davrods | . iCAT database tier . The iCAT database tier provisions the host with the following: . | PostgreSQL database | iRODS database plugin | . iCAT server . The iCAT server tier provisions the host with the following: . | iRODS iCAT server &amp; runtime | iRODS microservices | iRODS resource configuration | Yoda ruleset | . iRODS resource server . The iRODS resource server tier provisions the host with the following: . | iRODS resource server &amp; runtime | iRODS microservices | Yoda ruleset | . ",
    "url": "/yoda/design/overview/deployment.html#ansible-playbook",
    "relUrl": "/design/overview/deployment.html#ansible-playbook"
  },"53": {
    "doc": "Deployment",
    "title": "Roles",
    "content": "All the roles can be found in the roles directory using the following content organization: . roles/ common/ # this hierarchy represents a \"role\" tasks/ # main.yml # tasks file can include smaller files if warranted handlers/ # main.yml # handlers file templates/ # files for use with the template resource ntp.conf.j2 # templates end in .j2 files/ # bar.txt # files for use with the copy resource foo.sh # script files for use with the script resource defaults/ # main.yml # default variables for this role meta/ # main.yml # role dependencies apache/ # same kind of structure as \"common\" was above, done for the apache role certificates/ # \"\" composable-resources/ # \"\" hostentries/ # \"\" irods-database/ # \"\" irods-icat/ # \"\" irods-icommands/ # \"\" irods-microservices/ # \"\" irods-resource/ # \"\" irods-runtime/ # \"\" postgresql/ # \"\" python-irodsclient/ # \"\" python3/ # \"\" yoda-davrods/ # \"\" yoda-landingpages/ # \"\" yoda-moai/ # \"\" yoda-portal/ # \"\" yoda-rulesets/ # \"\" yoda-test/ # used in the test.yml playbook yoda-zabbixagent # used in the zabbix.yml playbook yoda-zabbixdatabase # used in the zabbix.yml playbook yoda-zabbixyodaitems # used in the zabbix.yml playbook . ",
    "url": "/yoda/design/overview/deployment.html#roles",
    "relUrl": "/design/overview/deployment.html#roles"
  },"54": {
    "doc": "Deployment",
    "title": "Environments",
    "content": "The playbook can be used with different environments. Each environment has its own inventory (hosts) with all instances. Each instance is configured in group variables (group_vars). Host specific variables (host_vars) may exist for each host. environments/ development/ allinone/ hosts # inventory file for allinone instance group_vars/ allinone.yml # here we assign variables to particular groups host_vars/ combined # if systems need specific variables, put them here full/ hosts # inventory file for full instance group_vars/ full.yml # here we assign variables to particular groups host_vars/ portal # if systems need specific variables, put them here database # \"\" icat # \"\" resource # \"\" public # \"\" testing/ instance/ hosts # inventory file for testing environment group_vars/ instance.yml # here we assign variables to particular groups host_vars/ hostname1 # if systems need specific variables, put them here hostname2 # \"\" acceptance/ instance/ hosts # inventory file for acceptance environment group_vars/ instance.yml # here we assign variables to particular groups host_vars/ hostname1 # if systems need specific variables, put them here hostname2 # \"\" production/ instance/ hosts # inventory file for production environment group_vars/ instance.yml # here we assign variables to particular groups host_vars/ hostname1 # if systems need specific variables, put them here hostname2 # \"\" . ",
    "url": "/yoda/design/overview/deployment.html#environments",
    "relUrl": "/design/overview/deployment.html#environments"
  },"55": {
    "doc": "Deposit space",
    "title": "Deposit space",
    "content": " ",
    "url": "/yoda/design/overview/deposit-space.html",
    "relUrl": "/design/overview/deposit-space.html"
  },"56": {
    "doc": "Deposit space",
    "title": "Introduction",
    "content": "The deposit space is described in this document. The state diagram describes the possible states a folder in the deposit space can be in. In the sequence diagram the interactions between the actors in the research space are documented. ",
    "url": "/yoda/design/overview/deposit-space.html#introduction",
    "relUrl": "/design/overview/deposit-space.html#introduction"
  },"57": {
    "doc": "Deposit space",
    "title": "State diagram",
    "content": ". ",
    "url": "/yoda/design/overview/deposit-space.html#state-diagram",
    "relUrl": "/design/overview/deposit-space.html#state-diagram"
  },"58": {
    "doc": "Deposit space",
    "title": "Sequence diagram",
    "content": ". ",
    "url": "/yoda/design/overview/deposit-space.html#sequence-diagram",
    "relUrl": "/design/overview/deposit-space.html#sequence-diagram"
  },"59": {
    "doc": "Development tips",
    "title": "Development tips",
    "content": "A collection of tips to make Yoda development easier. ",
    "url": "/yoda/development/development-tips.html",
    "relUrl": "/development/development-tips.html"
  },"60": {
    "doc": "Development tips",
    "title": "General",
    "content": "Watch latest iRODS log without unnecessary noise: . ls -t /var/lib/irods/log/rodsLog* | head -n1 | xargs -n 1 -- tail -f | grep -v \"Agent process started for puser=rods\" . Watch flake8 check on Python code: . watch flake8 . Run flake8 check on source file change (requires the entr package): . ls *py | entr flake8 . Reload Flask on project change (requires the entr package; run as root): . cd /var/www/yoda &amp;&amp; find /etc/irods/yoda-ruleset . \\( -path *.swp -o -path */node_modules/* -o -path ./venv -o -path ./.git \\) -prune -o -print | entr touch yoda_debug.wsgi . Rebuild portal Javascript assets on source file change: ./node_modules/.bin/webpack -d -w . ",
    "url": "/yoda/development/development-tips.html#general",
    "relUrl": "/development/development-tips.html#general"
  },"61": {
    "doc": "Development tips",
    "title": "Mailpit",
    "content": "The development environments have Mailpit for testing email during development. In order to see what messages Yoda would have sent, browse to port 8025 on the iCAT or EUS server of the environment. ",
    "url": "/yoda/development/development-tips.html#mailpit",
    "relUrl": "/development/development-tips.html#mailpit"
  },"62": {
    "doc": "Development tips",
    "title": "Datarequest module",
    "content": "Remove all existing data requests (to declutter your development environment): . icd /tempZone/home/datarequests-research &amp;&amp; ils | grep \\ \\ | sed 's/\\ \\ C-\\ //' | xargs -I COLLPATH sh -c \"ichmod -M -r own rods COLLPATH &amp;&amp; irm -r COLLPATH\" . ",
    "url": "/yoda/development/development-tips.html#datarequest-module",
    "relUrl": "/development/development-tips.html#datarequest-module"
  },"63": {
    "doc": "External User Service",
    "title": "External User Service",
    "content": " ",
    "url": "/yoda/design/overview/external-user-service.html",
    "relUrl": "/design/overview/external-user-service.html"
  },"64": {
    "doc": "External User Service",
    "title": "Introduction",
    "content": "This technical design document describes an approach to implementing support for enrolling, removing, authenticating, and changing &amp; resetting the password of external users in Yoda. ",
    "url": "/yoda/design/overview/external-user-service.html#introduction",
    "relUrl": "/design/overview/external-user-service.html#introduction"
  },"65": {
    "doc": "External User Service",
    "title": "Definitions",
    "content": ". | Internal user An internal user is either a user within the UU organisation or an administrative user such as rods. | External user An external user is a user that is not part of the UU organisation. External users must have an e-mail address as their username, that does not end in either @uu.nl or .uu.nl. Any username that is an e-mail address and does not match above pattern belongs to an external user. | . ",
    "url": "/yoda/design/overview/external-user-service.html#definitions",
    "relUrl": "/design/overview/external-user-service.html#definitions"
  },"66": {
    "doc": "External User Service",
    "title": "Functional description",
    "content": "The supported workflows are as follows: . Enrolling an external user . A group manager must be able to enroll an external user. When a group manager adds a new external user to a group, an invite must be sent to the e-mail address belonging to the new user. The invite must contain a generated unique URL that links to a page allowing the user to create a password and activate their account. The link must be invalidated either after activation, or if the external user does not create a password within 5 days. Authenticating an external user . An external user must be able to authenticate themselves via any available iRODS interface that offers PAM login. Resetting or changing the password of an external user . An external user must be able to reset their password. When a user submits their e-mail address to the external user service, they will receive a password reset link. Password restrictions based on information security guidelines are applied. Removing external users . An Yoda admin can remove an external user. After user deletion the external user service is notified and deletes the user. ",
    "url": "/yoda/design/overview/external-user-service.html#functional-description",
    "relUrl": "/design/overview/external-user-service.html#functional-description"
  },"67": {
    "doc": "External User Service",
    "title": "General architecture",
    "content": "Component view . ",
    "url": "/yoda/design/overview/external-user-service.html#general-architecture",
    "relUrl": "/design/overview/external-user-service.html#general-architecture"
  },"68": {
    "doc": "External User Service",
    "title": "Components",
    "content": "External user database . The external user database must store the username, password, creator and creator zone of external users. Additionally, a hash can be stored to allow for either account activation or password reset. When an external user is no longer linked to user_zones the user can be deleted from the users table as well. This could be a fully automated process later. The external user database contains the following tables: . users: . | Col. name | Type | Description | . | id | SERIAL | Numerical (autoincremented) ID used for internal purposes | . | username | VARCHAR(64) NOT NULL | The e-mail address of the external user case-insensitive) | . | password | CHAR(60) NULL | A hashed password (NULL indicates non-activated account) | . | hash | CHAR(64) NULL | A unique hash, used for activation and password reset | . | hash_time | TIMESTAMP NULL | The creation time of the hash, used to invalidate hashes | . | creator_time | TIMESTAMP NOT NULL | The creation time of the user | . | creator_user | VARCHAR(255) NOT NULL | The username of the group manager that had this external user ‘created’ | . | creator_zone | VARCHAR(255) NOT NULL | The zone the groupmananger is inviting the user from | . | Index | Type | . | id | PRIMARY | . | username | UNIQUE | . | hash | UNIQUE | . The 64-char username limit is prescribed by the iCAT (DB_USERNAME_LEN). user_zones: . | Col. name | Type | Description | . | user_id | INTEGER | ID of the user involved | . | inviter_user | VARCHAR(255) NOT NULL | The groupmanager that invited the external user | . | inviter_zone | VARCHAR(255) NOT NULL | The zone the groupmanager invited the external user from | . | inviter_time | TIMESTAMP NOT NULL | The invitation time of the user | . | Index | Type | Description | . | (user_id, inviter_zone) | PRIMARY | A user can only be added to a certain zone once. | . ",
    "url": "/yoda/design/overview/external-user-service.html#components",
    "relUrl": "/design/overview/external-user-service.html#components"
  },"69": {
    "doc": "External User Service",
    "title": "Yoda portal",
    "content": "The Yoda portal login page shows a “Forgot / change password” button. On click, the “Forgot password” page on the external user service for external users is displayed. When entering an internal email the internal user should be pointed to the correct location. Group manager . The Group manager portal module does not need to be changed to allow for external user creation. It currently allows creation of users with an e-mail address as their username. ",
    "url": "/yoda/design/overview/external-user-service.html#yoda-portal",
    "relUrl": "/design/overview/external-user-service.html#yoda-portal"
  },"70": {
    "doc": "External User Service",
    "title": "Yoda iRODS service",
    "content": "Authentication . External users will authenticate to iRODS using PAM. A PAM rule must be added (after pam_unix and pam_radius_auth) that will authenticate against the external user database. The PAM succeed_if module must be used in combination with “skip” actions to select the right authentication module based on a username glob. This will speed up authentication significantly. There is a PAM-pgsql module that would allow PAM to check credentials directly against the database, however, it has some drawbacks: . | This module does not exist in CentOS7 repos. We would need to compile it from source (and audit it). | The module does not seem to support a safe password hashing algorithm (only MD5, SHA1, clear, or a DB function (which would require a separate PostgreSQL package to support anything other than MD5)) | . Instead, the pam_exec module will be used together with curl to deliver a Basic-authed HTTPS POST request to the external user service, which will indicate success using the appropriate HTTP status code combined with an indicative response body text. This allows the external user database to be closed to outside connections, as the external user service is the only service that needs to access the database directly. The iRODS server will need a secret number (API key) to authenticate itself to the external service. This number must be stored as a local file on the server (not within iRODS), in a way that makes it accessible both to the PAM module and a Python Group manager rule. Addition: The external user service keeps track of the zones an external user is invited to. When authenticating, if a user is not registered within the eus for a zone, the user will not be able to log in to the corresponding Yoda instance. Group and user management . The Group manager rules will need to be able to instruct the external user service to create and remove external user accounts. These requests must be authenticated with an API key, which must be available to the iRODS service account, but not accessible to user-submitted rules. A Python rule is used to fetch the secret from a local file and make requests to the external user service. Since Python rules can be called from anywhere in iRODS, the rule itself will need to perform authorization checks, using existing Group manager policy check functions uuGroupPolicyCanGroupUserAdd and uuGroupPolicyCanGroupUserRemove. External users are removed when they are removed from the last Yoda instance. A periodic cleanup job may be implemented to automate external user removal. ",
    "url": "/yoda/design/overview/external-user-service.html#yoda-irods-service",
    "relUrl": "/design/overview/external-user-service.html#yoda-irods-service"
  },"71": {
    "doc": "External User Service",
    "title": "External user service",
    "content": "The external user service is a HTTPS server that services requests to a user management API, used by iRODS; and provides an interface for external users to activate their account, and change or reset their password. The iRODS server, which is the client to the API provided by this service, is to be fully trusted, and is thus expected to perform all necessary authorization checks before making a request. The service will have exclusive access to the external user database. Additionally, the service must be able to send e-mails to external users and group managers. E-mails are used for invitations and password resets. ",
    "url": "/yoda/design/overview/external-user-service.html#external-user-service-1",
    "relUrl": "/design/overview/external-user-service.html#external-user-service-1"
  },"72": {
    "doc": "External User Service",
    "title": "Sequence diagrams",
    "content": "Authentication of an external user . Enrollment of an external user not known to EUS . Invitation of external user known to EUS . Password reset . Deletion of an external user . ",
    "url": "/yoda/design/overview/external-user-service.html#sequence-diagrams",
    "relUrl": "/design/overview/external-user-service.html#sequence-diagrams"
  },"73": {
    "doc": "External User Service",
    "title": "Interfaces",
    "content": "Yoda portal → iRODS . The interface between the Yoda portal and iRODS is unchanged. iRODS → HTTP API → External user service . The external user service's HTTP API is used by iRODS to authenticate external users and enroll and remove external users. All requests from iRODS to the external user service must contain the header X-Yoda-External-User-Secret, containing a secret API key. When the secret header is not present, the external user service will respond with a 400 HTTP status code on all API requests. Additionally, API requests will be restricted to client IP addresses matching the iRODS server. POST parameters, if any, are supplied in the request body in JSON format, for example: . { \"username\": \"piet@example.com\", \"creator_user\": \"gm@example.com\", \"creator_zone\": \"tempZone\" } . | Endpoint | Method | Description | . | /api/auth-check | POST | User authentication: Credentials supplied via HTTP Basic Authorization header.. Response: On failure: 401. On success: 200, with body text Authenticated | . | /api/user/add | POST | User creation: Creates the given user in the external user database. Generates and stores an activation hash for that username. Sends an invitation e-mail to the new user. Parameters are username, creator_user and creator_zone. | . | /api/user/delete | POST | User removal: Removes the given user from the external user database. Parameters are username and userzone. | . ",
    "url": "/yoda/design/overview/external-user-service.html#interfaces",
    "relUrl": "/design/overview/external-user-service.html#interfaces"
  },"74": {
    "doc": "External User Service",
    "title": "External user → HTTP UI → External user service",
    "content": "The HTTP UI is used by the external user to activate their account, and to change or reset their password. All POST parameters are sent in x-www-form-urlencoded format. POST actions that require the use of a hash must fail if the hash is older than the specified time: . | For account creation: 5 days | For password reset: 15 minutes | . | Endpoint | Method | Description | . | /user/:username/activate/:hash | GET | User activation page. Allows the user confirm the creation of their account. | . | /user/:username/activate/:hash | POST | Confirms user activation, sets a password. Also sends an e-mail to the creator of the account. The user’s hash is cleared in the database upon use. The only parameter is password. | . | /user/forgot-password | GET | “Forgot password” page. Allows the user to request a password reset link by filling in their username | . | /user/:username/forgot-password | POST | Confirms “forgot password”. Generates a hash and sends a password reset link to the given username, if it exists. The only parameter is username. | . | /user/:username/reset-password/:hash | GET | Password reset page. Allows the user to enter a new password | . | /user/:username/reset-password/:hash | POST | Confirms password reset, sets a new password. The user’s hash is cleared in the database upon use. The only parameter is password. | . ",
    "url": "/yoda/design/overview/external-user-service.html#external-user--http-ui--external-user-service",
    "relUrl": "/design/overview/external-user-service.html#external-user--http-ui--external-user-service"
  },"75": {
    "doc": "Group manager",
    "title": "Group manager",
    "content": "The Yoda group-manager is a central tool for all Yoda implementations. The group-manager is used to control access permissions of users based on group membership and the role inside a group. As this usecase is not fully anticipated in the iRODS ACL (Access Control List) system, the group-manager makes use of shadow groups and metadata to accomplish its goals. To understand the choices made in the group-manager you need to understand the limitations of iRODS. The main goal of the group-manager is to enable the distribution of access rights to data within Yoda with minimal aid of the Yoda administrators. All data within Yoda belongs to a group within a community and access is granted by group membership and roles. ",
    "url": "/yoda/design/overview/group-manager.html",
    "relUrl": "/design/overview/group-manager.html"
  },"76": {
    "doc": "Group manager",
    "title": "Yoda roles",
    "content": "normal Has read and write access to the data of the group it belongs to. Most researchers will be assigned this role. reader Has read access to the data. This role could be assigned to users with interest in the data like master students. groupmanager Can add users to a group and assign them roles. Every group should have at least one groupmanager. This role is typically assigned to a principal investigator. datamanager Has read access to data belonging to his/her community and the ability to manage archival process and metadata quality. ",
    "url": "/yoda/design/overview/group-manager.html#yoda-roles",
    "relUrl": "/design/overview/group-manager.html#yoda-roles"
  },"77": {
    "doc": "Group manager",
    "title": "Yoda workspaces",
    "content": "Within a Yoda community multiple workspaces can be created of different types. They are prefixed to indicate this type. Every workspace is located in the /{rodsZone}/home collection. Davrods and the research browser have this location as start location. research Collaboration workspace for a research group. No restrictions on the organization of data in folders. Metadata can be added to a folder. When all required metadata has been added a folder can be archived. intakeA strict folder structure and filename structure is required to extract metadata and archive data in an intake workspace. grp Legacy workspaces are prefixed with grp-. They were created before the development of research workspaces. The current group-manager will prohibit the creation of new grp groups, but supports managing existing ones. ",
    "url": "/yoda/design/overview/group-manager.html#yoda-workspaces",
    "relUrl": "/design/overview/group-manager.html#yoda-workspaces"
  },"78": {
    "doc": "Group manager",
    "title": "Category and subcategories",
    "content": "To allow different communities to share the same Yoda implementation the concept of categories and subcategories were introduced. Every group has a category and subcategory. Within the group-manager groups are grouped into a tree of categories and subcategories. ",
    "url": "/yoda/design/overview/group-manager.html#category-and-subcategories",
    "relUrl": "/design/overview/group-manager.html#category-and-subcategories"
  },"79": {
    "doc": "Group manager",
    "title": "The iRODS permission system",
    "content": ". | iRODS has four user types: . | rodsuser, a normal user | rodsadmin, a superuser which can invoke commands in admin mode. | groupadmin, a user capable of adding other users to groups it belongs to. Not used by Yoda | rodsgroup, a group of users. Permissions granted to a rodsgroup apply to it’s members. | . | A Group is also a user. In the iRODS datamodel they share a table. Groups have a separate table to list members. | A group can not include another group. The hierarchy is flat. Groups have users as members, users can join multiple groups. | Permissions on Collections and DataObjects are either ‘own’, ‘write’ or ‘read’ set per user (a group is a user in this context). own has write, write implies read. | Group permissions set on collections only apply on subcollections if “inherit” is set. | iRODS allows federation of users between zones. To distinguish between local users and users from other zones, every query involving users should include the zone name. Users from different zones can be represented by appending a # and the zonename to the username. Example: myuser becomes myuser#myzone | . ",
    "url": "/yoda/design/overview/group-manager.html#the-irods-permission-system",
    "relUrl": "/design/overview/group-manager.html#the-irods-permission-system"
  },"80": {
    "doc": "Group manager",
    "title": "The sudo microservices",
    "content": "To enable ordinary rodsusers to create groups and manage members in groups, without promoting them to rodsadmin, the sudo microservices have been developed. They give temporary admin privileges when an action meets all criteria set in policies. Technically this means that a sudo microservice will set the AUTH flags in the iRODS rei structure to run an action as admin. Care is taken to prevent the use of these services outside of the proper context. ",
    "url": "/yoda/design/overview/group-manager.html#the-sudo-microservices",
    "relUrl": "/design/overview/group-manager.html#the-sudo-microservices"
  },"81": {
    "doc": "Group manager",
    "title": "How are the roles in Yoda implemented on top of the iRODS permission system?",
    "content": "Normal users are added to a group with the same name as its workspace. Example: normal users of research-breakthrough are added to the rodsgroup research-breakthrough. During group creation by the group-manager this group will get permission ‘own’ on the /{rodsZone}/home/research-breakthrough workspace and inheritance is enabled. A reader cannot be added to the main group, because that will grant them ‘own’ permissions. Instead a shadow group is created prefixed with ‘read-‘. This group gets read permissions on the ‘research-‘ or ‘intake-‘ group of the same basename. Inheritance is enabled . A group manager has all the same characteristics as a normal user but in addition metadata is set on the group to list managers. The attribute name is ‘manager’ and the attribute value is the username (including zone). There are two special groups under the System category to grant managers extra privileges. These are: . | priv-group-add – Membership of this group is checked to determine if a user can create groups. The user also needs to be manager in one of the groups belonging to the same category. | priv-category-add – Members of this group can create new categories. This is done when a new group is created. Because categories are implemented as metadata on groups, removing all groups from a category removes that category. | . A datamanager is not a member of a group belonging to a workspace. Instead a special ‘datamanager-‘ group needs to be created per category. This group has to have the same name as that category. This group is given read access to every workspace in this category. This allows the datamanager to check the quality of data and metadata before archiving the work. ",
    "url": "/yoda/design/overview/group-manager.html#how-are-the-roles-in-yoda-implemented-on-top-of-the-irods-permission-system",
    "relUrl": "/design/overview/group-manager.html#how-are-the-roles-in-yoda-implemented-on-top-of-the-irods-permission-system"
  },"82": {
    "doc": "Group manager",
    "title": "iRODS ruleset",
    "content": "The following files in the yoda-ruleset support the groupmanager. uuSudoPolicies Set of policies for every sudo action. Every action is denied by default. uuGroupPolicies Policies specific for actions related to the group manager. They have been specified seperately so the rules in uuSudoPolicies can be kept as simple as possible . uuGroupPolicyChecks Can be used by the portal and by rules. Queries related to policies . uuGroup Can be used by the portal and by policies. It contains the queries used directly by th Group Manager. Policies should not be used directly by the group manager. The files represent layers when calling functions. uuSudoPolicies -&gt; uuGroupPolicies -&gt; uuGroupPolicyChecks -&gt; uuGroup . uuGroup (Group manager portal functions) -&gt; uuGroupPolicyChecks . ",
    "url": "/yoda/design/overview/group-manager.html#irods-ruleset",
    "relUrl": "/design/overview/group-manager.html#irods-ruleset"
  },"83": {
    "doc": "Group manager",
    "title": "Users and groups",
    "content": "Users and groups are in same namespace, so checks are in place to prevent creating a group with the same name as a user. ",
    "url": "/yoda/design/overview/group-manager.html#users-and-groups",
    "relUrl": "/design/overview/group-manager.html#users-and-groups"
  },"84": {
    "doc": "Group manager",
    "title": "Vault",
    "content": "The vault group has only rods as member. the base group should get read-only access. Removal of a vault group through the group-manager is impossible. ",
    "url": "/yoda/design/overview/group-manager.html#vault",
    "relUrl": "/design/overview/group-manager.html#vault"
  },"85": {
    "doc": "Hotfixing ruleset",
    "title": "Applying a local change to a ruleset",
    "content": "This page describes a method for making a temporary local change (hotfix) to a ruleset. Such a hotfix can be used temporarily for testing. If the change is to be kept permanently, it is advisable to deploy the change using Ansible. The commands below can be executed using the iRODS service account. | First clone another copy of the ruleset: cd /etc/irods git clone https://github.com/UtrechtUniversity/yoda-ruleset.git hotfix . | Make changes to the ruleset (for example, meta.py) and compile the ruleset: cd hotfix vim meta.py make install . | Change the symlink to the fixed ruleset: cd /etc/irods ln -sfn hotfix rules_uu . | . If the change does not have the desired result, revert to the old ruleset by changing the symlink back and compiling the ruleset: . cd /etc/irods ln -sfn yoda-ruleset rules_uu cd yoda-ruleset make install . ",
    "url": "/yoda/administration/hotfixing-ruleset.html#applying-a-local-change-to-a-ruleset",
    "relUrl": "/administration/hotfixing-ruleset.html#applying-a-local-change-to-a-ruleset"
  },"86": {
    "doc": "Hotfixing ruleset",
    "title": "Hotfixing ruleset",
    "content": " ",
    "url": "/yoda/administration/hotfixing-ruleset.html",
    "relUrl": "/administration/hotfixing-ruleset.html"
  },"87": {
    "doc": "Development",
    "title": "Development",
    "content": ". | Setting up development environment | Running API and UI tests | Setting up YodaDrive development environment | Mock tape archive | Development tips | Wall of Fame | . ",
    "url": "/yoda/development/",
    "relUrl": "/development/"
  },"88": {
    "doc": "Administration Tasks",
    "title": "Administration Tasks",
    "content": ". | Configuring Yoda | Deploying Yoda | Applying a temporary local change to a ruleset | Applying a permanent local change to a ruleset | Installing licenses | Installing terms | Installing preservable file formats | Installing metadata schemas | Installing datarequest module | Working with the local Postfix MTA | Upgrading metadata schemas | Troubleshooting email | Troubleshooting publication | Troubleshooting replication and revision creation | Restore collection | Configuring OIDC | Setting job flags | Configuring cleanup temporary files | . ",
    "url": "/yoda/administration/",
    "relUrl": "/administration/"
  },"89": {
    "doc": "Release Notes",
    "title": "Release Notes",
    "content": ". | Release Notes - Yoda v1.9 (TBA) | Release Notes - Yoda v1.8 (July 2022) | Release Notes - Yoda v1.7 (May 2021) | Release Notes - Yoda v1.6 (May 2020) | Release Notes - Yoda v1.5 (July 2019) | Release Notes - Yoda v1.4 (December 2018) | Release Notes - Yoda v1.3 (November 2018) | Release Notes - Yoda v1.2 (May 2018) | Release Notes - Yoda v1.1 (March 2018) | Release Notes - Yoda v1.0 (November 2017) | Release Notes - Yoda v0.9.7 (August 2017) | . ",
    "url": "/yoda/release-notes/",
    "relUrl": "/release-notes/"
  },"90": {
    "doc": "API",
    "title": "API",
    "content": "Core API . | Core API documentation | . Module API . | Intake API documentation | Datarequest API documentation | . ",
    "url": "/yoda/design/api/",
    "relUrl": "/design/api/"
  },"91": {
    "doc": "Metadata",
    "title": "Metadata",
    "content": " ",
    "url": "/yoda/design/metadata/",
    "relUrl": "/design/metadata/"
  },"92": {
    "doc": "Other",
    "title": "Other",
    "content": " ",
    "url": "/yoda/design/other/",
    "relUrl": "/design/other/"
  },"93": {
    "doc": "System Overview",
    "title": "System overview",
    "content": "Yoda is a research data management service that enables researchers and their partners to securely deposit, share, publish and preserve large amounts of research data during all stages of a research project. Yoda consists of several core modules and has several additional modules providing additional functionality. ",
    "url": "/yoda/design/overview/#system-overview",
    "relUrl": "/design/overview/#system-overview"
  },"94": {
    "doc": "System Overview",
    "title": "Core modules",
    "content": "Research space . The research space implements a data deposit workflow to the vault space. Technical design . Vault space . The vault space implements a FAIR data publication workflow. Technical design . Statistics . The statistics module provides insight in research groups storage usage. Technical design . Group manager . The group-manager is used to control access permissions of users based on group membership and the role inside a group. It enables the distribution of access rights to data within Yoda with minimal aid of administrators. Technical design . User . The user module provides settings and notifications. ",
    "url": "/yoda/design/overview/#core-modules",
    "relUrl": "/design/overview/#core-modules"
  },"95": {
    "doc": "System Overview",
    "title": "Additional modules",
    "content": "Intake . This module processes uploaded YOUth programme experiment data, and facilitate its archival in the vault by a data manager. Technical design . Datarequest . Module adding support for the submission, review and approval of requests to obtain research data stored in Yoda. Technical design . Deposit space . The deposit space implements a data deposit workflow to the vault space. Technical design . ",
    "url": "/yoda/design/overview/#additional-modules",
    "relUrl": "/design/overview/#additional-modules"
  },"96": {
    "doc": "System Overview",
    "title": "Overview",
    "content": ". ",
    "url": "/yoda/design/overview/#overview",
    "relUrl": "/design/overview/#overview"
  },"97": {
    "doc": "System Overview",
    "title": "System Overview",
    "content": " ",
    "url": "/yoda/design/overview/",
    "relUrl": "/design/overview/"
  },"98": {
    "doc": "Processes",
    "title": "Processes",
    "content": " ",
    "url": "/yoda/design/processes/",
    "relUrl": "/design/processes/"
  },"99": {
    "doc": "Software Design",
    "title": "Software Design",
    "content": " ",
    "url": "/yoda/design/",
    "relUrl": "/design/"
  },"100": {
    "doc": "Software Design",
    "title": "API",
    "content": ". | API documentation | . ",
    "url": "/yoda/design/#api",
    "relUrl": "/design/#api"
  },"101": {
    "doc": "Software Design",
    "title": "System",
    "content": ". | System overview | Research space | Vault space | Statistics module | Intake module | Datarequests module | Group manager | Authentication | Theme Packages | External User Service | Yoda OAI-PMH endpoint | . ",
    "url": "/yoda/design/#system",
    "relUrl": "/design/#system"
  },"102": {
    "doc": "Software Design",
    "title": "Metadata",
    "content": ". | Metadata schema identifier | Metadata form | Metadata mappings | Metadata schemas | . ",
    "url": "/yoda/design/#metadata",
    "relUrl": "/design/#metadata"
  },"103": {
    "doc": "Software Design",
    "title": "Processes",
    "content": ". | Asynchronous and privileged execution | List of asynchronous processes | Locking mechanism | Publication process | Revision management | Vault process | . ",
    "url": "/yoda/design/#processes",
    "relUrl": "/design/#processes"
  },"104": {
    "doc": "Software Design",
    "title": "Other",
    "content": ". | Python plugin | Yoda drive | . ",
    "url": "/yoda/design/#other",
    "relUrl": "/design/#other"
  },"105": {
    "doc": "Home",
    "title": "Yoda technical documentation",
    "content": "On this website you can find release notes and technical documentation on software design and administration tasks of Yoda. ",
    "url": "/yoda/#yoda-technical-documentation",
    "relUrl": "/#yoda-technical-documentation"
  },"106": {
    "doc": "Home",
    "title": "Get started now View it on GitHub",
    "content": " ",
    "url": "/yoda/#get-started-now-view-it-on-github",
    "relUrl": "/#get-started-now-view-it-on-github"
  },"107": {
    "doc": "Home",
    "title": "What is this?",
    "content": "Yoda is a research data management service that enables researchers and their partners to securely deposit, share, publish and preserve large amounts of research data during all stages of a research project. ",
    "url": "/yoda/#what-is-this",
    "relUrl": "/#what-is-this"
  },"108": {
    "doc": "Home",
    "title": "Latest release",
    "content": ". | Release Notes - Yoda v1.8 (July 2022) | . ",
    "url": "/yoda/#latest-release",
    "relUrl": "/#latest-release"
  },"109": {
    "doc": "Home",
    "title": "Documentation style",
    "content": "All documentation is styled using Markdown. All UML diagrams are generated with PlantUML. ",
    "url": "/yoda/#documentation-style",
    "relUrl": "/#documentation-style"
  },"110": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/yoda/",
    "relUrl": "/"
  },"111": {
    "doc": "Installing datarequest module",
    "title": "Installing datarequest module",
    "content": " ",
    "url": "/yoda/administration/installing-datarequest-module.html",
    "relUrl": "/administration/installing-datarequest-module.html"
  },"112": {
    "doc": "Installing datarequest module",
    "title": "Before deployment using Ansible",
    "content": "Enable the datarequest module in Ansible . Set enable_datarequest to true in configuration. enable_datarequest: true . Set Ansible parameters specific to the datarequest module . Users can contact a helpdesk email address for questions regarding the datarequest procedure. Set the fields below to specify the help contact. datarequest_help_contact_name: the data manager datarequest_help_contact_email: help@yoda.instance . Add the yoda-portal-datarequest repository to extra_modules. extra_modules: - name: datarequest repo: \"https://github.com/UtrechtUniversity/yoda-portal-datarequest.git\" dest: /var/www/yoda/yoda-portal/modules/datarequest version: \"\" . ",
    "url": "/yoda/administration/installing-datarequest-module.html#before-deployment-using-ansible",
    "relUrl": "/administration/installing-datarequest-module.html#before-deployment-using-ansible"
  },"113": {
    "doc": "Installing datarequest module",
    "title": "After deployment using Ansible",
    "content": "Creating and populating required groups . Ensure that the following groups exists, each with category datarequests, subcategory research and data classification unspecified: datarequests-research-datamanagers datarequests-research-project-managers datarequests-research-data-access-committee datarequests-research-principal-investigators datarequests-research-faculty-deans . Instructions: . | Log into an account on the server with permission to create new groups. sudo su irods . | Create the groups. irule -r irods_rule_engine_plugin-irods_rule_language-instance 'uuGroupAdd(\"datarequests-research-datamanagers\", \"datarequest\", \"research\", \"Datamanagers\", \"\", *status, *message);' null ruleExecOut irule -r irods_rule_engine_plugin-irods_rule_language-instance 'uuGroupAdd(\"datarequests-research-project-managers\", \"datarequest\", \"research\", \"Project managers\", \"\", *status, *message);' null ruleExecOut irule -r irods_rule_engine_plugin-irods_rule_language-instance 'uuGroupAdd(\"datarequests-research-data-access-committee\", \"datarequest\", \"research\", \"Data Access Committee\", \"\", *status, *message);' null ruleExecOut irule -r irods_rule_engine_plugin-irods_rule_language-instance 'uuGroupAdd(\"datarequests-research-principal-investigators\", \"datarequest\", \"research\", \"Principal investigators\", \"\", *status, *message);' null ruleExecOut irule -r irods_rule_engine_plugin-irods_rule_language-instance 'uuGroupAdd(\"datarequests-research-faculty-deans\", \"datarequest\", \"research\", \"Faculty deans\", \"\", *status, *message);' null ruleExecOut . | Confirm that the groups exist. iadmin lg . | . Using the group manager, populate these groups with appropriate members. Updating the data request module schemas . If data request module schemas are already present, they will not be overwritten when the Ansible playbook is executed. The data request module schemas can be updated by executing /etc/irods/yoda-ruleset/tools/install-datarequest-schemas.sh $zoneName. ",
    "url": "/yoda/administration/installing-datarequest-module.html#after-deployment-using-ansible",
    "relUrl": "/administration/installing-datarequest-module.html#after-deployment-using-ansible"
  },"114": {
    "doc": "Installing Licenses",
    "title": "Background",
    "content": "Researchers can specify the license of a data package in its metadata. They can either use a standard license (e.g. Creative Commons Attribution 4.0 International Public License), or use a custom license. If the metadata of a data package specifies the name of a standard license (i.e. any license other than Custom), Yoda will include the license text in a License.txt file in the root of the package when it is copied to the vault. The URI of the license will be included in the metadata. ",
    "url": "/yoda/administration/installing-licenses.html#background",
    "relUrl": "/administration/installing-licenses.html#background"
  },"115": {
    "doc": "Installing Licenses",
    "title": "Installing licenses",
    "content": "This section explains how to upload license texts and URIs, so that Yoda can automatically include them in data packages. In the example commands below, replace ${RODSZONE} with the iRODS zone name. Replace ${LICENSE} with the name of the license, as defined in the metadata schema. Yoda will look for the license text in /${RODSZONE}/yoda/licenses/${LICENSE}.txt and for the license URI in /${RODSZONE}/yoda/licenses/${LICENSE}.uri. ",
    "url": "/yoda/administration/installing-licenses.html#installing-licenses",
    "relUrl": "/administration/installing-licenses.html#installing-licenses"
  },"116": {
    "doc": "Installing Licenses",
    "title": "Installing default licenses",
    "content": "The files of the licenses included in the default metadata schema can be found in /etc/irods/yoda-ruleset/licenses. The command to upload these license files to Yoda is: . iput -r /etc/irods/yoda-ruleset/licenses /${RODSZONE}/yoda . ",
    "url": "/yoda/administration/installing-licenses.html#installing-default-licenses",
    "relUrl": "/administration/installing-licenses.html#installing-default-licenses"
  },"117": {
    "doc": "Installing Licenses",
    "title": "Installing non-default licenses",
    "content": "Put the license text in a file named ${LICENSE}.txt. The {LICENSE}.txt file needs to be pure ASCII, in order to ensure it will be displayed correctly on every operating system and in every browser1. The license URI should be in a file named ${LICENSE}.uri. iput \"${LICENSE}.txt\" \"/${RODSZONE}/yoda/licenses/${LICENSE}.txt\" iput \"${LICENSE}.uri\" \"/${RODSZONE}/yoda/licenses/${LICENSE}.uri\" . ",
    "url": "/yoda/administration/installing-licenses.html#installing-non-default-licenses",
    "relUrl": "/administration/installing-licenses.html#installing-non-default-licenses"
  },"118": {
    "doc": "Installing Licenses",
    "title": "Footnotes",
    "content": ". | UTF-8 is not an option, because browsers will display a .txt file with the windows-1252 encoding. The ANSI subset of the windows-1252 encoding is not an option, because Mac and linux will not correctly detect ANSI in a .txt file if opened from the web disk. &#8617; . | . ",
    "url": "/yoda/administration/installing-licenses.html#footnotes",
    "relUrl": "/administration/installing-licenses.html#footnotes"
  },"119": {
    "doc": "Installing Licenses",
    "title": "Installing Licenses",
    "content": " ",
    "url": "/yoda/administration/installing-licenses.html",
    "relUrl": "/administration/installing-licenses.html"
  },"120": {
    "doc": "Installing metadata schemas",
    "title": "Installing metadata schemas",
    "content": "For a fully functional research module, a metadata schema is required. All schemas can be found in the yoda-ruleset in schemas/. Below a description of the needed files per schema (using the default schema as example): . metadata.json A JSON file describing the metadata form. uischema.json A JSON file describing how a given data type should be rendered as a form input component. It provides information on how the form should be rendered. In the default situation the default schema is installed in /${RODSZONE}/yoda/schemas/default. Example to install (or update) schema ‘default-2’ as default for all categories: . irsync -Krv -R irodsResc /etc/irods/yoda-ruleset/schemas/default-2/ i:/${RODSZONE}/yoda/schemas/default/ . If you install the files in a directory with the same name as the name of a category it will become the schema for that category and that category alone, when the category is created afterwards. Existing categories without a specific schema will still use the default schema. Example to install (or update) schema ‘core-1’ for category ‘experimental’: . irsync -Krv -R irodsResc /etc/irods/yoda-ruleset/schemas/core-1/ i:/${RODSZONE}/yoda/schemas/experimental/ . The above is legal bash if you define RODSZONE environment variable, for example: . export RODSZONE=tempZone . Mistakes are easily made as the commands are so similar, but different. So please take care. ",
    "url": "/yoda/administration/installing-metadata-schemas.html",
    "relUrl": "/administration/installing-metadata-schemas.html"
  },"121": {
    "doc": "Installing lists of preservable file formats",
    "title": "Installing lists of preservable file formats",
    "content": "Preservable file formats are read from iRODS and presented to the user. It needs to be a JSON (.json) file which validates against the JSON schema below. The naming scheme is up to the administrator, the lists ar presented alphabetically. In order for every user to be able to read the terms, a read ACL for public needs to be set. iput -r /etc/irods/yoda-ruleset/tools/file_formats /${RODSZONE}/yoda ichmod -rM inherit /${RODSZONE}/yoda/file_formats ichmod -rM read public /${RODSZONE}/yoda/file_formats . To add a new list of preservable file formats just put a JSON file in the /${RODSZONE}/yoda/file_formats collection with a new name. iput \"${FILE_FORMATS}.json\" \"/${RODSZONE}/yoda/file_formats/${FILE_FORMATS}.json\" . JSON schema for preservable file formats: . { \"definitions\": {}, \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"$id\": \"preservable_file_formats.json\", \"type\": \"object\", \"title\": \"List of preservable file formats\", \"required\": [ \"name\", \"formats\" ], \"properties\": { \"name\": { \"$id\": \"#/properties/name\", \"type\": \"string\", \"title\": \"File formats list name\", \"default\": \"\", \"examples\": [ \"DANS Preferred formats\" ], \"pattern\": \"^(.*)$\" }, \"help\": { \"$id\": \"#/properties/help\", \"type\": \"string\", \"title\": \"File formats list help text\", \"default\": \"\", \"pattern\": \"^(.*)$\" }, \"advice\": { \"$id\": \"#/properties/advice\", \"type\": \"string\", \"title\": \"File formats list advice text\", \"default\": \"\", \"pattern\": \"^(.*)$\" }, \"formats\": { \"$id\": \"#/properties/formats\", \"type\": \"array\", \"title\": \"List of file formats\", \"default\": null, \"items\": { \"$id\": \"#/properties/formats/items\", \"type\": \"string\", \"title\": \"Preservable file formats\", \"default\": \"\", \"examples\": [ \"pdf\", \"txt\", \"xml\", \"html\", \"css\", \"ods\", \"csv\", \"sql\", \"jpg\", \"tiff\", \"png\", \"svg\" ], \"pattern\": \"^(.*)$\" } } } } . ",
    "url": "/yoda/administration/installing-preservable-file-formats.html",
    "relUrl": "/administration/installing-preservable-file-formats.html"
  },"122": {
    "doc": "Installing Terms & Conditions",
    "title": "Installing Terms &amp; Conditions",
    "content": "Terms and conditions for publication are also read from iRODS and presented to the user. It needs to be an HTML snippet to be rendered correctly. The naming scheme is up to the administrator, the last .html file placed in /rodsZone/yoda/terms will become the text presented to the user. In order for every user to be able to read the terms, a read ACL for public needs to be set. iput -r /etc/irods/yoda-ruleset/tools/terms /${RODSZONE}/yoda ichmod -rM inherit /${RODSZONE}/yoda/terms ichmod -rM read public /${RODSZONE}/yoda/terms . To add a new terms file just put it in the /${RODSZONE}/yoda/terms collection with a new name, so the old terms are preserved. iput \"${TERMS}.txt\" \"/${RODSZONE}/yoda/terms/${TERMS}.html\" . All vault packages with an action log record “submitted for publication” from before the create time of the new terms file were accepted under the old terms. ",
    "url": "/yoda/administration/installing-terms.html#installing-terms--conditions",
    "relUrl": "/administration/installing-terms.html#installing-terms--conditions"
  },"123": {
    "doc": "Installing Terms & Conditions",
    "title": "Installing Terms & Conditions",
    "content": " ",
    "url": "/yoda/administration/installing-terms.html",
    "relUrl": "/administration/installing-terms.html"
  },"124": {
    "doc": "Intake module",
    "title": "Intake module",
    "content": " ",
    "url": "/yoda/design/overview/intake.html",
    "relUrl": "/design/overview/intake.html"
  },"125": {
    "doc": "Intake module",
    "title": "Introduction",
    "content": "This page describes the specifications of the Yoda intake module. The main purpose of this module is to process uploaded YOUth programme experiment data, and facilitate its archival in the vault by a data manager. Experiment data would first be uploaded into an intake folder by a lab assistant or other employee (“intaker”). The intake module has a scan function the data manager can use to extract dataset information from file and folder names so that data can be grouped by dataset. Finally, the data manager can use the intake module to lock datasets in the Yoda vault. The rest of this page contains specifications of the expected data object and collection names. ",
    "url": "/yoda/design/overview/intake.html#introduction",
    "relUrl": "/design/overview/intake.html#introduction"
  },"126": {
    "doc": "Intake module",
    "title": "Data object and collection name specifications",
    "content": "Allowed characters . Data object names (file names) and collection names (folder names) should consist of only these characters: . | Letters, either upper case or lower case (Latin alphabet: a-z, A-Z) | Digits: 0-9 | Underscores (_) | Hyphens (-) | Dots (.) | . WEPV data in names . Datasets are identified by WEPV properties (Wave, Experiment, Pseudo code, Version) which are derived from data object and/or collection names. The wave, experiment and pseudo code elements are compulsory. The version element is optional, and has a default value of “Raw”. Either underscores (“_”) or hyphens (“-“) can be used as separators between WEPV elements in data object or collection names. WEPV elements may be defined at different levels in the tree. WEPV elements in a path are processed from left to right. The first folder which has complete WEPV data (i.e. wave, experiment and pseudo code are present in the path of the folder, including its parent folders) is considered to be the root folder of the dataset. If only the data object itself has complete WEPV data, the data object itself is considered to be the root of the dataset. Here is an example of a data object in a dataset: . Y:/grp-vault-youth/malu/20w/echo/Y2015M05/D27/20w_B54321/I0000000.vol ^^^^^^^^^^ . In this example, the experiment type element (“echo”) is defined at a different level from the wave (“20w”) and pseudo ID (“B54321”) element. The folder indicated by the carets is considered to be the root folder of the dataset, since it is the topmost folder with complete WEPV element data. Wave values . Waves before birth have a “w” (week) suffix, whereas waves after birth have a month (“m”) or year (“y”) suffix. The 9y, 12y and 15y waves are part of the adolescent cohort, whereas the other waves are part of the baby / child cohort. Valid waves are: . | 20w | 30w | 0m | 5m | 10m | 3y | 6y | 9y | 12y | 15y | . Experiment type values . Valid experiment types are: . | pci | echo | faceemo | coherence | infprogap | infsgaze | infpop | chprogap | chantigap | chsgaze | pciconflict | pcivacation | peabody | discount | cyberball | trustgame | other | inhibmockbehav | inhibmribehav | emotionmribehav | emotionmriscan | anatomymriscan | restingstatemriscan | dtiamriscan | dtipmriscan | mriqcreport | mriqceval | vasmri | vasmock | looklisten | handgame | infpeabody | delaygratification | dtimriscan | inhibmriscan | chdualet | functionalmriscan | infdualet | . The “other” type is used for questionnaires, logs and unknown types of data. Pseudo code format . Pseudo codes consist of a letter “a” (adolescent), “b” (baby) or “p” (adolescent pilot) followed by five digits. Version format . Version elements consist of “ver”, followed by a version name. The version element is optional, and defaults to a version named “Raw”. The version name must begin with an upper case letter. The version name must consist of only alphanumeric characters. Examples: . | verRaw | verVersionName | . ",
    "url": "/yoda/design/overview/intake.html#data-object-and-collection-name-specifications",
    "relUrl": "/design/overview/intake.html#data-object-and-collection-name-specifications"
  },"127": {
    "doc": "Intake module",
    "title": "Acknowledgements and provenance",
    "content": "This page is based on the original specification document titled Yoda — Youth Cohort Data Intake Specificaties, by Jonas Sweep, Chris Smeele and Ton Smeele, version 0.12. Information regarding quality criteria specific to experiment types has not been copied from the original document, since quality checks specific to experiment types have been removed from the intake module. ",
    "url": "/yoda/design/overview/intake.html#acknowledgements-and-provenance",
    "relUrl": "/design/overview/intake.html#acknowledgements-and-provenance"
  },"128": {
    "doc": "Local Postfix MTA",
    "title": "Working with the local Postfix MTA",
    "content": " ",
    "url": "/yoda/administration/local-postfix-mta.html#working-with-the-local-postfix-mta",
    "relUrl": "/administration/local-postfix-mta.html#working-with-the-local-postfix-mta"
  },"129": {
    "doc": "Local Postfix MTA",
    "title": "Background",
    "content": "The Yoda External User Service (EUS) and the main ruleset send email messages to users. In the standard configuration, the EUS and ruleset send messages directly to a relay server, which would typically be your organization’s email server. Alternatively, the EUS and ruleset can be configured to send messages to a local Postfix Mail Transfer Agent. Postfix then takes care of delivering the messages to a relay host, such as your organization’s email server. ",
    "url": "/yoda/administration/local-postfix-mta.html#background",
    "relUrl": "/administration/local-postfix-mta.html#background"
  },"130": {
    "doc": "Local Postfix MTA",
    "title": "Advantages",
    "content": "The main advantages of using Postfix rather than sending email messages directly to the organizational email server are: . | If Yoda delivers emails directly to the organizational email server, any connection or availability issues can result in user actions failing. For example, if a Yoda user creates a new external account by adding an email address of a new user to a research group, the user will see an error message if the email server is not available. If Yoda uses Postfix, account creation will succeed, and Postfix will take care of delivering the message asynchronously. | Postfix automatically retries delivering emails in case of transient errors, whereas Yoda and the EUS don’t have this capability in the default configuration. | Postfix has proper logging of email message delivery, whereas Yoda and the EUS have very limited email logging in the default configuration. Complete logging makes it possible to verify that emails have been sent, and to find the cause of any problems in case something has gone wrong. | . In summary, using Postfix as a local MTA makes email delivery more resilient and helps with troubleshooting. ",
    "url": "/yoda/administration/local-postfix-mta.html#advantages",
    "relUrl": "/administration/local-postfix-mta.html#advantages"
  },"131": {
    "doc": "Local Postfix MTA",
    "title": "Configuration",
    "content": "Configuration consists of three parts: . | Configure Postfix | Configure the EUS to send emails to the Postfix instance | Configure Yoda (ruleset) to send emails to the Postfix instance | . Postfix . In order to configure Postfix, you will need an account that can be used for sending email messages using Secure SMTP. Example configuration: . enable_postfix: true postfix_relayhost: smtp.myuniversity.nl postfix_myhostname: yoda.myuniversity.nl postfix_relayhost_username: smtpaccount@myuniversity.nl postfix_relayhost_password: myPassword . EUS . Configure the EUS to send email messages to the local Postfix instance: . eus_smtp_host: localhost eus_smtp_port: 25 eus_smtp_auth: false eus_smtp_security: false . Yoda ruleset . Configure the Yoda ruleset to send email messages to the local Postfix instance: . smtp_server: smtp://localhost:25 smtp_auth: false smtp_starttls: false . See also . | Troubleshooting email | . ",
    "url": "/yoda/administration/local-postfix-mta.html#configuration",
    "relUrl": "/administration/local-postfix-mta.html#configuration"
  },"132": {
    "doc": "Local Postfix MTA",
    "title": "Local Postfix MTA",
    "content": " ",
    "url": "/yoda/administration/local-postfix-mta.html",
    "relUrl": "/administration/local-postfix-mta.html"
  },"133": {
    "doc": "Local ruleset patches",
    "title": "Local ruleset patches",
    "content": "In some cases, you might want to make some local modifications to a ruleset in order to modify Yoda’s behaviour. This can be achieved by defining a patch parameter for a ruleset. You would usually create a patch value using a command like: git diff | sed 's/^/ /' on your modified ruleset. If patch is set to “” (empty string), no patch is applied. This effectively resets any earlier local changes deployed via Ansible. If you want to remove a local patch, you would first need to run the playbook with an empty patch value in order to reset earlier patches. After that, you can remove the patch value. ",
    "url": "/yoda/administration/local-ruleset-patch.html",
    "relUrl": "/administration/local-ruleset-patch.html"
  },"134": {
    "doc": "Local ruleset patches",
    "title": "Example",
    "content": "This example patch changes the UUPRIMARYRESOURCES constant in the ruleset code. core_rulesets: - name: yoda-ruleset repo: https://github.com/UtrechtUniversity/yoda-ruleset.git ruleset_name: rules-uu version: \"\" patch: | diff --git a/uuConstants.r b/uuConstants.r index 5311d5c..aa44bad 100644 --- a/uuConstants.r +++ b/uuConstants.r @@ -36,7 +36,7 @@ UURESOURCETIERATTRNAME = UUORGMETADATAPREFIX ++ 'storage_tier'; UUMETADATASTORAGEMONTH = UUORGMETADATAPREFIX ++ 'storage_data_month'; # \\constant UUPRIMARYRESOURCES -UUPRIMARYRESOURCES = list(\"irodsResc\"); +UUPRIMARYRESOURCES = list(\"irodsResc3\"); # \\constant UUREPLICATIONRESOURCE UUREPLICATIONRESOURCE = \"irodsRescRepl\"; install_scripts: yes - name: core ruleset_name: core path: /etc/irods/core.re install_scripts: no . ",
    "url": "/yoda/administration/local-ruleset-patch.html#example",
    "relUrl": "/administration/local-ruleset-patch.html#example"
  },"135": {
    "doc": "Local ruleset patches",
    "title": "Considerations",
    "content": ". | The playbook temporarily restores the original ruleset and then re-applies the patch. This could constitute a risk if the local modifications are related to safety or security. | You would need to verify for yourself that the patch is still compatible with the latest version of the ruleset before running the playbook. Having the playbook apply a patch that is no longer compatible with the ruleset code may cause Yoda to fail. | . ",
    "url": "/yoda/administration/local-ruleset-patch.html#considerations",
    "relUrl": "/administration/local-ruleset-patch.html#considerations"
  },"136": {
    "doc": "Local ruleset patches",
    "title": "See also",
    "content": "This page is about making local changes to rulesets that can be deployed via Ansible. This method is typically used for long-term changes. If you want to make a short-term change (e.g. a temporary change for testing), you might want to consider using a hotfix instead. ",
    "url": "/yoda/administration/local-ruleset-patch.html#see-also",
    "relUrl": "/administration/local-ruleset-patch.html#see-also"
  },"137": {
    "doc": "Folder Locking mechanism",
    "title": "Folder Locking mechanism",
    "content": "To prevent modification of a folder in the research area, a researcher can use the lock function. This will catch attempts to write or remove data to that folder until the folder is unlocked again. The same mechanism is used to prevent modification during the status transitions needed to put a folder in to the vault. The iRODS ACL system could not be used, because researcher should be able to lock/unlock a folder themselves and not rely on an administrator to do so. This document describes the technical implementation of the locking mechanism in the research ruleset. Locks are represented by metadata on the folder, it’s children and it’s parents. The lock consists of a AVU with org_lock (defined in iiConstants.r) as attribute name and the collection where the lock is started (rootCollection). Whenever a lock is set this AVU is put on every child using a treewalk and every parent using iteration until the /{rodsZone}/home/research-{groupName} collection is found. Every relevant static Policy Enforcement Point that could be triggered because of a modification in the research area is checked for the metadata and in general the following rules are enforced: . | if the root collection of the lock is on the current collection or a parent collection disallow the action. | if the root collection of the lock is on a child collection allow modification of data objects, but disallow renames of parent collections. | . In case there is a source and destination object, both need to be checked for locks and the following rules apply: . | if the source is locked, but the destination is not then disallow move operations, but allow copy operations. | if the destination is locked, disallow every action. | . msiOprDisallowed and msiDeleteDisallowed are used to stop the current operation and return an error to the clients. There is one unfortunate special case. There is no static PEP for preconditions on a file put operation, only a post PEP. To prevent users from putting new files into a locked collection the files are removed in the post condition acPostProcForPut. When using webDAV it may appear like the file is still there due to caching. ",
    "url": "/yoda/design/processes/locking-mechanism.html",
    "relUrl": "/design/processes/locking-mechanism.html"
  },"138": {
    "doc": "Folder Locking mechanism",
    "title": "Setting and removing locks",
    "content": "The locks are set and removed with the iiFolderLockChange rule in the iiFolderStatusTransition.r file. This rule should not be directly run, but triggered from folder status transitions. Please refer to the folder status design document for details on which transition should lock the folder. The rules in iiFolderStatusTransitions.r called by the front-end to initiate a status change will attempt a metadata change on the org_status attribute. This will trigger an metadata PEP, which will run the lock change when the current user is allowed to. Every folder status transition is checked for preconditions by the iiCanModifyFolderStatus rule in iiPolicyChecks.r. When the locking fails, the modification of the org_status change will be interrupted by calling msiOprDisallowed. For the rules called by the front-end the errors are caught and returned with statusInfo. ",
    "url": "/yoda/design/processes/locking-mechanism.html#setting-and-removing-locks",
    "relUrl": "/design/processes/locking-mechanism.html#setting-and-removing-locks"
  },"139": {
    "doc": "Metadata JSON schema",
    "title": "JSON schema for Yoda",
    "content": "Yoda uses the REACT library for its configurable metadata forms. The content of a specific form is held within a JSON schema. Thus each category (=community) can have its own metadata. And consequently its own metadata form. ",
    "url": "/yoda/design/metadata/metadata-form-json.html#json-schema-for-yoda",
    "relUrl": "/design/metadata/metadata-form-json.html#json-schema-for-yoda"
  },"140": {
    "doc": "Metadata JSON schema",
    "title": "$id",
    "content": "Each json schema starts with the id of the schema. This is used as a means to uniquely identify the schema. Also, it is used to be able to create XSD’s with the JSONS2XSD-tool in determining the namespaces as well as location of the resulting XSD’s. \"$id\": \"https://yoda.uu.nl/schemas/default-0/metadata.json\", . ",
    "url": "/yoda/design/metadata/metadata-form-json.html#id",
    "relUrl": "/design/metadata/metadata-form-json.html#id"
  },"141": {
    "doc": "Metadata JSON schema",
    "title": "Definitions - General",
    "content": "Within JSON schema, within the definitions section, metadata can be described. Definitions Data type, length and enumerations . Strings . Yoda string type defitions: . \"stringNormal\": { \"type\": \"string\", \"maxLength\": 255 }, \"stringLong\": { \"type\": \"string\", \"maxLength\": 2700 }, . These definitions can be used for elements within the jsons form: . \"properties\": { \"Title\": { \"$ref\": \"#/definitions/stringNormal\", \"title\": \"Title\" }, \"Description\": { \"$ref\": \"#/definitions/stringLong\", \"title\": \"Description\" }, . Thus describing a ‘Title’ element of datatype stringNormal. And ‘Description’ of datatype stringLong. Enumerations . \"optionsLicense\": { \"type\": \"string\", \"enum\": [ \"Creative Commons Attribution 4.0 International Public License\", \"Creative Commons Attribution-ShareAlike 4.0 International Public License\", \"Open Data Commons Attribution License (ODC-By) v1.0\", \"Custom\" ] }, . Form element ‘License’ is described using optionsLicense . \"License\": { \"$ref\": \"#/definitions/optionsLicense\", \"title\": \"License\" }, . Default values for elements . REACT form allows default values to be set. \"Discipline\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/optionsDiscipline\", \"title\": \"Discipline\", \"default\": \"\" } . The default value is ‘’ - an empty string (which is not part of the selection list optionsDiscipline) . Multiplicity - type=’array’ . Giving a user the possibility to add specific data multiple times is achieved by using the type ‘array’. This is an indication that the element involved can be added multiple times. \"Discipline\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/optionsDiscipline\", \"title\": \"Discipline\", \"default\": \"\" } }, . The above example will show a Selection field holding all present options for disciplines. ",
    "url": "/yoda/design/metadata/metadata-form-json.html#definitions---general",
    "relUrl": "/design/metadata/metadata-form-json.html#definitions---general"
  },"142": {
    "doc": "Metadata JSON schema",
    "title": "Complex structures - type=’object’",
    "content": "In order to be able to serve the need to create structures of data the type ‘object’ is used. Object in fact constructs a structure that it holds one ore more other elements. The properties attribute holds the elements that constitute this structure. \"Collected\": { \"type\": \"object\", \"title\": \"Collection process\", \"yoda:structure\": \"compound\", \"properties\": { \"Start_Date\": { \"type\": \"string\", \"format\": \"date\", \"title\": \"Start date\" }, \"End_Date\": { \"type\": \"string\", \"format\": \"date\", \"title\": \"End date\" } }, }, . The above example shows a structure of data with title ‘Collection process’. It will show two elements ‘Start date’ and ‘End date’. The data itself is singular. I.e. only one start date and one end date can be added by the user. Dependencies between elements . Dependencies can be added between data. I.e. if data is present in one element, the other element becomes mandatory as well. \"Collected\": { \"type\": \"object\", \"title\": \"Collection process\", \"yoda:structure\": \"compound\", \"properties\": { \"Start_Date\": { \"type\": \"string\", \"format\": \"date\", \"title\": \"Start date\" }, \"End_Date\": { \"type\": \"string\", \"format\": \"date\", \"title\": \"End date\" } }, \"dependencies\": { \"Start_Date\": [\"End_Date\"], \"End_Date\": [\"Start_Date\"] } }, . In the example above, Start date and end date are dependent fields. I.e. if either one is holding data, the other field must hold data as well. ",
    "url": "/yoda/design/metadata/metadata-form-json.html#complex-structures---typeobject",
    "relUrl": "/design/metadata/metadata-form-json.html#complex-structures---typeobject"
  },"143": {
    "doc": "Metadata JSON schema",
    "title": "Specific Yoda structure attributes",
    "content": "yoda:structure @TODO -compound A combination of form elements that can be regarded as one element. -Subproperties A subproperty structure is contstructed of 1 main item and a properties section. This section can be an elaborate structure of formelements in itself -required . “yoda:required”: true Yoda specific indication for handling of mandatoriness of array elements. ",
    "url": "/yoda/design/metadata/metadata-form-json.html#specific-yoda-structure-attributes",
    "relUrl": "/design/metadata/metadata-form-json.html#specific-yoda-structure-attributes"
  },"144": {
    "doc": "Metadata JSON schema",
    "title": "Example of complex structure",
    "content": "Following example show a complex datastructure for Contributor entity. Main structure Main structure is a subproperty structure. It consists of Name as leadpropery and the entire structure below as its subproperty. The entire Contributor structure can be duplicated. I.e. copied including the entire subpropery structure. Subproperty structure Consists of 2 elements (Contributor type and Affiliation) and 1 compound element Person identifier (holding 2 compound elements). Affiliation and Person Identifier can be added multiple times. When a Person identifier type is added, a corresponding identifier is required as well. This is arranged by setting dependencies between the two fields. JSON representation is as follows: . \"Contributor\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"yoda:structure\": \"subproperties\", \"properties\": { \"Name\": { \"$ref\": \"#/definitions/stringNormal\", \"title\": \"Contributor to datapackage\" }, \"Contributor_Type\": { \"$ref\": \"#/definitions/optionsContributorType\", \"title\": \"Contributor type\" }, \"Affiliation\": { \"type\": \"array\", \"default\": [\"Utrecht University\"], \"items\": { \"$ref\": \"#/definitions/stringNormal\", \"title\": \"Affiliation\", \"yoda:required\": true } }, \"Person_Identifier\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"title\": \"Person identifier\", \"yoda:structure\": \"compound\", \"properties\": { \"Name_Identifier_Scheme\": { \"$ref\": \"#/definitions/optionsNameIdentifierScheme\", \"title\": \"Type\" }, \"Name_Identifier\": { \"$ref\": \"#/definitions/stringNormal\", \"title\": \"Identifier\" } }, \"dependencies\": { \"Name_Identifier_Scheme\": [\"Name_Identifier\"], \"Name_Identifier\": [\"Name_Identifier_Scheme\"] } } } }, \"dependencies\": { \"Name\": [\"Contributor_Type\", \"Affiliation\"] } } }, . ",
    "url": "/yoda/design/metadata/metadata-form-json.html#example-of-complex-structure",
    "relUrl": "/design/metadata/metadata-form-json.html#example-of-complex-structure"
  },"145": {
    "doc": "Metadata JSON schema",
    "title": "Metadata JSON schema",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-form-json.html",
    "relUrl": "/design/metadata/metadata-form-json.html"
  },"146": {
    "doc": "Metadata form",
    "title": "Metadata form",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-form.html",
    "relUrl": "/design/metadata/metadata-form.html"
  },"147": {
    "doc": "Metadata form",
    "title": "Introduction",
    "content": "A Yoda instance holds research information regarding communities (categories). The type of research data can differ between communities. Metadata, that has to be registered together with research data, can differ as well between communities. Yoda supports communities to use their own metadata accompanying their research by giving them the support of a specific metadata form. If no form exists for a specific community then the standard metadata form is used. ",
    "url": "/yoda/design/metadata/metadata-form.html#introduction",
    "relUrl": "/design/metadata/metadata-form.html#introduction"
  },"148": {
    "doc": "Metadata form",
    "title": "Generic implementation",
    "content": "The metadata form handling is technically implemented in a generic manner. Within Yoda is it used in . | RESEARCH area to view/edit/add metadata for a dataset that will be placed in the vault. All in terms of the corresponding community | VAULT area to view/edit/add the metatadata that accompanied a datasets when accepted for the vault. All in terms of the corresponding community | DATAREQUEST module Given the generic implementation of the form it is utilized in a whole different context for the DATAREQUEST module within Yoda. | . Only the Research and Vault implementation is discussed in this document. ",
    "url": "/yoda/design/metadata/metadata-form.html#generic-implementation",
    "relUrl": "/design/metadata/metadata-form.html#generic-implementation"
  },"149": {
    "doc": "Metadata form",
    "title": "Form functionality",
    "content": "The metadata form handling is implemented in a generic manner. In itself the generic metadata form deals with two situations, i.e. | an editable form in which users can edit/add metadata to a datapackage | a readonly view on this metadata as previously entered by a researcher | . What the generic (metadata) form deals with: . | Presenting a form for the metadata of a specific datapackage where the elements on the form are configurable dependent on category | A default metadata form configuration when no metadata form configuration exists for a category | Possibility to have dependencies between elements on the form in order to form clear relations between the data | Determining completeness of the form and giving proper indications to the user dependent on the category a datapackage belongs to | Determining validity of the metadata form data dependent on the category a datapackage belongs to | Saving the metadata to a file in XML format within the datapackage (called yoda-metadata.xml) The file that can be edited via web disk as well by users with sufficient permissions | When data is saved correctly add the metadata to iCAT system as AVU’s to the corresponding datapackage information as well. This so these metadata entries can be searched by users | Offering possibilities to, after correctly/successfully validating a metadata set, the result can be used for further actions. Like the ability . | to bring a datapackage / metadata to the vault from within the dynamic storage environment | to save several metadata files, with unique names, within the vault | . | readonly view on metadata for a datapackage | . REACT FORM Within Yoda, REACT is the center for metadata form handling. It gives the development team more flexibility in extending form possibilities. REACT relies on JSON data and JSON validation schema’s. Within Yoda metadata is kept in XML (filename is yoda-metadata.xml). That is why internally transformations will have to take place from JSON to XML and vice versa. Data validation (when submitting metadata for the vault) will still take place based on XSD’s. Yoda metadata is still saved in XML and as such available/accessible for the enduser. ",
    "url": "/yoda/design/metadata/metadata-form.html#form-functionality",
    "relUrl": "/design/metadata/metadata-form.html#form-functionality"
  },"150": {
    "doc": "Metadata form",
    "title": "Integral part of Yoda",
    "content": "React-form . In essence React-form is a fully configurable form handler that is based on javascript and JSON schema. Fields can be configured using javascript classes. The form can be fully integrated in an application like for instance Yoda. | Data can be exported (posted) to the application’s backend | Data can be imported into the form and presented in the form’s fields | . ",
    "url": "/yoda/design/metadata/metadata-form.html#integral-part-of-yoda",
    "relUrl": "/design/metadata/metadata-form.html#integral-part-of-yoda"
  },"151": {
    "doc": "Metadata form",
    "title": "Yoda integration",
    "content": "Import yoda-metadata.xml and presentation in the form . Yoda-backend serves the frontend in creating a page holding the react form as a fully integrated part of Yoda. metadata.JSON holds the full definition of the form and is used for validation purposes as well. yoda-metadata.xml, the file that holds previously saved metadata, is transformed in terms of the metadata.JSON so the form can present the data. Export (JSON to XML) . When a user fills out the form and presses ‘Save’, the data is posted to the indicated backend. This JSON response is transformed into the collection specific yoda-metadata.xml. Deviations from standard React form . Yoda has some clear deviations from the standard functionality of React form. This to be able to mimic the behaviour of the preceding (own development) form that did not use JSON form yet. Default handling of React form is that when fields are clonable they are initially not visible. Only after hitting the (add) button they become visible. There are challenges in correctly initializing array fields. Our own Yoda form requires clonable fields to be present in the form already. Specific options menu depending on working in research or vault area . Depending on the area/module a user is working in, different options become available in the options menu. Research area . ‘To vault’ functionality Request a dataset in the research area to be saved into the vault. Vault area . ‘Publish’ functionality Request publication of a dataset in the vault. ",
    "url": "/yoda/design/metadata/metadata-form.html#yoda-integration",
    "relUrl": "/design/metadata/metadata-form.html#yoda-integration"
  },"152": {
    "doc": "Metadata form",
    "title": "Basic structure",
    "content": "The metadata form is based on React library (https://reactjs.org/) a javascript library intended for frontend purposes. This is fitted into the place where the (now obsolete) previous version of metadata handling was situated. React replaces the older metadata handling processes completely. Required files and purposes . | React library javascript library. This forms the generic basis for the frontend.   | metadata.json - JSON schema A JSON file that mainly holds the structural definition of the metadata form as well as mandatoriness. This file has been designed for the Yoda implementation and is based on the JSON schema specification (https://json-schema.org/). The metadata.json file mainly holds all information for the metadata form: . | Declaration of groups of elements | Element names corresponding to the XSD | Element specifics intended for the researcher, like . | Label of the input element | tooltips when hovering over the field | Default value when no metadata has been saved yet | . | Mandatoriness of metadata Metadata fields can be configured as being mandatory when requested to be accepted in the vault. Special mandatoryness-rules apply for compound fields and subproperty structures. This is discusses further in this document. | . | research.XSD The research XSD is used to validate and describe metatadata that is in the research area. This XSD is in fact a translation of the corresponding JSON schema. To be able to do so, an application (json-to-xsd) was created. | vault.XSD The vault XSD is used to validate metadata before it is allowed to be entered in the vault area. This XSD is in fact a translation of the corresponding JSON schema. To be able to do so, an application (json-to-xsd) was created. | yoda-metadata.xml Holds, in XML format, the metadata as entered by the user. This, either after a save action of the user from within the form, or when edited directly when using a webDAV client. The XML data should comply to the corresponding XSD before the metadata can be accepted into the vault. | . Complex Data structures . Subproperty structure . Subproperties designate a structure consisting of . | one lead element | N elements (subproperties) linked to the lead element organised as one group | . The lead elemenent can be of every type as mentioned earlier. Implicit mandatoriness . Subproperties cannot exist without the lead information being present. Saving subproperties that have no lead-data will be deleted when saved. I.e. the lead information becomes implicitly mandatory when subproperty data exists. Mandatory subproperty within a subproperty structure . A subproperty can be configured as being mandatory. This rule only applies when lead information is present. Multiplicity/cloning for subproperty structure: . The entire structure can be cloned (if set to multiple within the JSONS). Subproperties themselves can be cloned if configured in JSONS Compound fields (see further) can be treated as subproperties and all the above rules will be applicable to these a well (and their own compound properties will be maintained as well) . Compound elements . A compound element is an element that consists of several, at least one, related elements. They are considered to belong together and in that sense treated in that manner. Multiplicity/cloning of compounds . Entire element can be made cloneable – thus cloning the total structure in its entirety . Each individual constructing element within the compound can be made cloneable as well– thus cloning the element within its compound element. Implicit mandatoriness when compound is partly filled. If one element of a compound is filled, all the others have to be filled as well. These are considered mandatory as well. Partly filling a compound is not accepted as being valid information . Compound field as a subproperty . A compound field can be regarded as being a single element. Therefore, it can also be used as a a subproperty. This is especially useful when the need exists to save the relation of one leading element and a set of information that belongs together. Mandatoriness . Again, if one of the compound elements fields holds data, the other element(s) become mandatory as well. I.e. data cannot be saved when a compound field is not fully filled out. Multiplicity/cloning entire compound . A compound field can be regarded as one element. Therefore, it can be cloned in its entirety adding one (or more) cloned compounds to the lead element. Multiplicity – cloning element(s) within a compound . As a compound is constructed with normal elements it is possible to add cloning to each or one specific element within a compound element. General validation rules for complex structures . Subproperties cannot exist without a lead/main property being present. I.e. A subproperty structure without lead information is regarded as incomplete information. As a result the corresponding datapackage will not be accepted for the vault. | A subproperty can be configured as being mandatory.* | . However, this rule is only valid when the corresponding lead element is filled. In other words, eventhough a mandatory rule exists on a subproperty, the actual subproperty-structure could still be configured as being none-mandatory for the vault. | Completeness of a compound field* | . Compounds are constructed of separate fields but can be regarded as one element. If one element of a compound field holds a value the other n fields should hold a value as well. | Completeness of a compound field as a subproperty* Compound fields within a subproperty structure follow the same rules as on highest level. I.e. when one element is filled, all elements must be filled. | . ",
    "url": "/yoda/design/metadata/metadata-form.html#basic-structure",
    "relUrl": "/design/metadata/metadata-form.html#basic-structure"
  },"153": {
    "doc": "Metadata form",
    "title": "Integration of REACT form within Yoda",
    "content": "The file .     Yoda-module/app/index.js . holds all Yoda-application specific javascript code to tweak the REACT form to the needs of the application. It handles all Yoda specific situations where the REACTform is involved. It integrates it within the Yoda application. Code changes do not directly take effect. In order to effectuate, use: ./node_modules/.bin/webpack -d in: /var/www/yoda/yoda-portal/modules/research . Since there is a separate vault module this will hold its own /app/index.js . ",
    "url": "/yoda/design/metadata/metadata-form.html#integration-of-react-form-within-yoda",
    "relUrl": "/design/metadata/metadata-form.html#integration-of-react-form-within-yoda"
  },"154": {
    "doc": "Metadata import and export",
    "title": "Metadata import and export functionality",
    "content": "The import and export functionality establishes the bridge between the REACT form, JSON schema based, and the Yoda application XML. In essence -the export functionality transforms the JSON data that was posted by the form into the yoda-metadata.xml conform the Yoda application requirements for the layout of the XML. -the import functionality transforms yoda-metadata.xml into JSON that is prepared for handling by he metadata form. ",
    "url": "/yoda/design/metadata/metadata-import-export-technical.html#metadata-import-and-export-functionality",
    "relUrl": "/design/metadata/metadata-import-export-technical.html#metadata-import-and-export-functionality"
  },"155": {
    "doc": "Metadata import and export",
    "title": "IMPORT",
    "content": "Purpose: Build JSON encoded data structure conform the REACT requirements to ‘feed’ the metadata form as such that Yoda is able to present a metadata form that resembles that original metadataform in functionality as well as gui. Example CONTRIBUTOR field . Internal PHP representation of contributor field as read from JSON schema. The import functionality within the portal software use this structure to be able to determine wheter data is present within yoda-metadata.xml The resulting JSON object is put to the REACT form. DIT IS PHP representatie - kan mogelijk anders worden ingezet (bij import????) . [type] = array [items] [type] =&gt; object – JSON form way of saying a nested structure is present [yoda:structure] =&gt; subproperties - YODA way of indicating which type of nested structure [properties] [Name] [$ref] =&gt; #/definitions/stringNormal [title] =&gt; Contributor to datapackage [Contributor_Type] [$ref] =&gt; #/definitions/optionsContributorType [title] =&gt; Contributor type [Affiliation] [type] =&gt; array [default] [0] =&gt; Utrecht University [items] [$ref] =&gt; #/definitions/stringNormal [title] =&gt; Affiliation [yoda:required] =&gt; 1 [Person_Identifier] [type] = array [items] [type] =&gt; object [title] =&gt; Person identifier [yoda:structure] =&gt; compound [properties] =&gt; Array [Name_Identifier_Scheme] =&gt; Array [$ref] =&gt; #/definitions/optionsNameIdentifierScheme [title] =&gt; Type [Name_Identifier] =&gt; Array [$ref] =&gt; #/definitions/stringNormal [title] =&gt; Identifier [dependencies] =&gt; Array [Name_Identifier_Scheme] [0] =&gt; Name_Identifier [Name_Identifier] =&gt; Array [0] =&gt; Name_Identifier_Scheme . ",
    "url": "/yoda/design/metadata/metadata-import-export-technical.html#import",
    "relUrl": "/design/metadata/metadata-import-export-technical.html#import"
  },"156": {
    "doc": "Metadata import and export",
    "title": "Export functionality",
    "content": "Purposes: . | Build yoda-metadata.xml based upon the posted output from the REACT form | Write metadata to iCAT database so it can be searched | . There are two steps involved when the researcher submits the data package to the vault . | save data in yoda-metadata.xml for the datapackage Based upon the form definition in formelements.xml the posted metadata is matched and saved into yoda-metadata.xml in the corresponding folder. | . | Data that is not ‘known’, i.e. not defined in formelements.xml is NOT saved. | Incomplete subproperty structures are NOT saved in this situation. | Data that is sent as empty strings will not be saved. This to keep the metadata that is registered in iCat as effective as possible and not be fully drained with empty metadata values | . | save data from yoda-metadata.xml into AVU’s for the datapackage Writing the metadata-xml file triggers an iRODS-policy to process the content of the file (in XML format), via a stylesheet, into AVU’s. The stylesheet ‘flattens’ the hierarchical XML formatted data so all values have an attribute like where all XML tags are places on one line, like: Contributor_Properties_Identifier_Person_Identifier_Scheme elaborated with numeric indexes if multiplicity is involved | . Step 2 also occurs when a researcher places a yoda-metadata.xml file on the web disk. The main definition can be found in JSON Schema definition . Subproperty structure: In XML a subproperty structure holds a tag to separate the leadproperty area in the structure from the subproperty area. This designation is not present within the JSON schema representation and has to be added while transforming the JSON data to XML . ** indexed search on metadata ** Adding values to the iRODS iCAT database, based upon an XSLT, makes search actions possible from the portal within the metadata. ",
    "url": "/yoda/design/metadata/metadata-import-export-technical.html#export-functionality",
    "relUrl": "/design/metadata/metadata-import-export-technical.html#export-functionality"
  },"157": {
    "doc": "Metadata import and export",
    "title": "Metadata import and export",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-import-export-technical.html",
    "relUrl": "/design/metadata/metadata-import-export-technical.html"
  },"158": {
    "doc": "Metadata mappings",
    "title": "Metadata mappings",
    "content": "When a datapackage with yoda-metadata.json is published it will be processed and converted to three different forms. If changes are made to the metadata.json. Jinja2 template for landing page . The landing page HTML code is generated using a Jinja2 template. This template may need to be adapted in case of metadata schema changes. The template can be found in /etc/irods/yoda-ruleset/templates/landingpage.html.j2. The Ansible playbook activates this template by uploading it to the /zone/yoda/templates/ collection. JSON generator for DataCite . For DataCite a JSON-file is generated conform the DataCite Schema v4. This generator can be found in /etc/irods/yoda-ruleset/json_datacite41.py. OAI-PMH importer . The OAI-PMH stream is updated by loading the yoda-metadata.json with a Python script. This Python script only looks for a couple of elements that map to Dublin core and DataCite. Any changes to these fields will omit this metadata from the stream. The mapping is documented outside of this document. ",
    "url": "/yoda/design/metadata/metadata-mappings.html",
    "relUrl": "/design/metadata/metadata-mappings.html"
  },"159": {
    "doc": "Metadata schema identifier",
    "title": "Metadata schema identifier",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html",
    "relUrl": "/design/metadata/metadata-schema-identifier.html"
  },"160": {
    "doc": "Metadata schema identifier",
    "title": "Introduction",
    "content": "Yoda needs to publish its metadata schemas. This document describes the principles and proposal for an URI structure to identify and locate the published schemas. ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html#introduction",
    "relUrl": "/design/metadata/metadata-schema-identifier.html#introduction"
  },"161": {
    "doc": "Metadata schema identifier",
    "title": "Principles",
    "content": ". | Referable: the URI needs to be referenced from metadata files. It should be easy to reference for human and machine readers: URI syntax, not too long, minimal characters that require encoding. The schemas will be public, so no authentication/authorization. | Scalable: The number of schemas will increase for different communities within and potentially outside UU, and there may be multiple schemas within a community, and there may be alternative serializations of a schema. We must ensure that each of these can be identified/referenced. | Identifiable: Each schema should be identified uniquely. Each identifier may not be reused for another schema, version and/or community. We will reserve latest and current as versions. | Durable: The references to the schemas may last for a long time. The solution must be able to survive most changes of the system and organizations so that these references remain valid. Thus a durable protocol (http), hostname (simple/governance) and path (easy to redirect via webserver) . | Maintainable: Easy to maintain structure and files via e.g. GIT, and to add new schemas or versions. | Automatable: The schemas will be retrieved mainly by software/machines. Identifier structure and location/retrieval-functions should comply with standards. We avoid the use of complex characters that will need encoding. | . ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html#principles",
    "relUrl": "/design/metadata/metadata-schema-identifier.html#principles"
  },"162": {
    "doc": "Metadata schema identifier",
    "title": "Proposal",
    "content": "We propose https://yoda.uu.nl/schemas/-/ . | https:// - protocol . | yoda.uu.nl – hostname . | /schemas – exclusive path reserved for schemas, to avoid conflicts with other resources on that the host. Implies that no other software on this host may use this path. | - can be anything, but must be unique for all schemas published at yoda.uu.nl. | - there can be multiple versions of a schema, which may be consecutive, but do not need to be. A schemaVersion must be unique per schemaName. We reserve latest and current as schemaVersions (this may be used as a symlink to the latest or current version in the future). | - metadata.json / uischema.json | . ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html#proposal",
    "relUrl": "/design/metadata/metadata-schema-identifier.html#proposal"
  },"163": {
    "doc": "Metadata schema identifier",
    "title": "FAQ",
    "content": ". | Why https? https can be addressed from iRODS environments. | Why yoda.uu.nl? We don’t want to depend on the current instances (i-lab, youth, ..) and don’t have sufficient authority on uu.nl. We don’t prefer data.uu.nl, as this may be addressed via other protocols than https, such as iRods. | Why no community in path? There are non-community schemas such as datacite and schemas shared among communities. One may refer to a community in the schemaName. | Why schemas and not meta? We assume that vocabularies or ‘non-informational URIs’ will be provided/published by another facility. Currently all published resources are related to a schema (definitions, transformations). | Why not use persistent identifiers? This provides complexity in maintenance and retrieval. We believe that a well-chosen URI scheme can address most issues that a PID addresses. | How to support research- and vault schemas? We may consider these to be different schemas, or different versions, or different representations of the same version. We consider the distinction between these as a work-around, hence we consider these to be different representations. | How to ensure uniqueness? This is ensured hierarchically. As we share the hostname and schema-path, only the schemaName, schemaVersion and combination of those should be governed. We propose to make Yoda administration responsible for the unique schemaNames, and the schemaVersions. To avoid mixup of names and versions, we prohibit the use of the separator (hyphen, “-“) within the schemaName and the schemaVersion. To avoid conflicts of typical schemaNames among communities, we recommend to prefix these with the community name. | How to determine equality? See RFC on URI syntax (this ignores e.g. portnumbers and authentication aspects in the URI, and considers the schema and hostname to be case insensitive). We recommend to treat schemaName, schemaVersion and schemaFile as case insensitive. | . ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html#faq",
    "relUrl": "/design/metadata/metadata-schema-identifier.html#faq"
  },"164": {
    "doc": "Metadata schema identifier",
    "title": "Yoda examples conform this proposal",
    "content": ". | default-1 metadata.json | default-1 uischema.json | . ",
    "url": "/yoda/design/metadata/metadata-schema-identifier.html#yoda-examples-conform-this-proposal",
    "relUrl": "/design/metadata/metadata-schema-identifier.html#yoda-examples-conform-this-proposal"
  },"165": {
    "doc": "Metadata schemas",
    "title": "Community dependent files for configuration of metadata handling",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-schemas.html#community-dependent-files-for-configuration-of-metadata-handling",
    "relUrl": "/design/metadata/metadata-schemas.html#community-dependent-files-for-configuration-of-metadata-handling"
  },"166": {
    "doc": "Metadata schemas",
    "title": "Community dependency",
    "content": "Within Yoda, research is supported via groups; administrative entities declaring which persons are allowed to participate in that particular research. Each group within Yoda belongs to a community. A community (=category) can hold multiple groups. Different communities may require community specific metadata to be added to their research datasets. Yoda is designed in such a way that each community can have its own metadata definition. It accommodates handling of community dependent metadata though configuration of the generic metadataform. If such a community specific definition is not present the system will fall back unto the default definition each Yoda instance is always equipped with. The metadata definition is declared in JSON schema’s. A metadata configuration file should always include all information that is required to be able to publish the research datapackage, including its metadata. The exact fields can be found in the core-0 schema. ",
    "url": "/yoda/design/metadata/metadata-schemas.html#community-dependency",
    "relUrl": "/design/metadata/metadata-schemas.html#community-dependency"
  },"167": {
    "doc": "Metadata schemas",
    "title": "Folder layout for category dependent schemas",
    "content": "Central folder for all configurational and statuent files related to metadata is: /zone/yoda/schemas . Category (=community) dependency is dealt with by using subfolders like: /zone/yoda/schemas/ilab . In this case ilab is the name of community “ilab”. Within the software presence of category configurations is always checked for first. If not available then the fallback is to the default configuration: . /zone/yoda/schemas/default . ",
    "url": "/yoda/design/metadata/metadata-schemas.html#folder-layout-for-category-dependent-schemas",
    "relUrl": "/design/metadata/metadata-schemas.html#folder-layout-for-category-dependent-schemas"
  },"168": {
    "doc": "Metadata schemas",
    "title": "Involved files and their purpose",
    "content": "Each folder will hold the following files: . metadata.json . Configuration for the metadata form as used for a community. uischema.json . UI configuration for the metadata form as used for a community. ",
    "url": "/yoda/design/metadata/metadata-schemas.html#involved-files-and-their-purpose",
    "relUrl": "/design/metadata/metadata-schemas.html#involved-files-and-their-purpose"
  },"169": {
    "doc": "Metadata schemas",
    "title": "Metadata schemas",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-schemas.html",
    "relUrl": "/design/metadata/metadata-schemas.html"
  },"170": {
    "doc": "Metadata transformations",
    "title": "Transformation of metadata within Yoda",
    "content": "Due to the fact that communities can change their requirements to their metadata Yoda allows for changes in metadata, i.e. metadata forms configuration. Comply to the latest schema! As a rule all metadata will have to comply to the latest corresponding schema. This has repercussions on metadata present in research and vault area. ",
    "url": "/yoda/design/metadata/metadata-transformation.html#transformation-of-metadata-within-yoda",
    "relUrl": "/design/metadata/metadata-transformation.html#transformation-of-metadata-within-yoda"
  },"171": {
    "doc": "Metadata transformations",
    "title": "Versions of schemas",
    "content": "To be able to perform data transformations it is required to know which transformation to perform. This is achieved by version control on the community XSD on one hand. On the other hand, yoda-metadata.xml, when metadata is saved from the form, the schemalocation (which includes its version) of the XSD at the time of saving metadata. Research area . - yoda-metadata.xml yoda-metadata.xml holds a schemaLocation. This designates the location of the publically accessible schema to which the data in yoda-metadata.xml must comply. As stated, the schema is under version control. *- The XML schemas for research and vault area (XSD) * Each Yoda-instance holds community based schemas internally for control of metadata integrity for that perticular community. In such a system community folder reside: . | research.xsd The schema to which yoda-metadata.xml in the research area must comply | vault.xsd The schema to which yoda-metadata.xml in the research area must comply | . The targetNamespace within the xsd determines the ID / version of the XSD . Both schemaLocation in yoda-metadata.xml and targetNamespace in corresponding xsd must be equal. If not, transformation of data in yoda-metadata.xml must take place. Actual transformation of metadata . Transformation is mainly achieved by using a stylesheet (xls) to convert data from one schemaID to another. If using a stylesheet proves too difficult, or even impossible, the transformation software is set up as such that programmically (Python) changes can be performed as well. Use of stylesheets is not a requirement for this purpose. After transformation . After transformation of the metadata in yoda-metadata.xml the origin file is backed up like: . yoda-metadata[5633743].xml . yoda-metadata.xml now holds the transformed data. And the schemaLocation is set to the correct schemaID. Thus safeguarding that no transformation will take place anymore. ",
    "url": "/yoda/design/metadata/metadata-transformation.html#versions-of-schemas",
    "relUrl": "/design/metadata/metadata-transformation.html#versions-of-schemas"
  },"172": {
    "doc": "Metadata transformations",
    "title": "Code:",
    "content": "Trap whether transformation is required### . PHP RESEARCH module: metadata.php-controller . yoda-metadata.xml schemaLocation is retrieved from xml =&gt; schemaID1 . yoda-metadata.xml path delivers category (default or specific) and xsd space (research.xsd or vault.xsd) targetNamespace is then retrieved from resulting xsd =&gt; schemaID2 . If difference exists between schemaLocation (of the user’s data) and targetNamespace of current xsd, schemaID1/schemaID2, then transformation has to take place. Do transformation - within yoda-ruleset . within iRods / iiSchemaUpdates.py: the tranformation matrix holds possible conversions from schemaIDn to schemaID(m) . transformationMethod = transformationMatrix[schemaID1][schemaID2] . The matrix brings up a function name that will transform the data. This can entail a scenario of steps to be taken. If possible simply by using a specific stylesheet. Sometimes more complicated actions have to take place. Usage of stylesheets A stylesheet is used to transform xml data from 1 version to another. Within the stylesheet all structural and dynamic data can be collected and returned as a the new yoda-metadata.xml. Namespaces required in stylesheet The original metadata is using a specific namespace in which the data ‘lives’. This has to be known in the transformation stylesheet as well. Otherwise, XPath queries will not result in any data! . Secondly, the stylesheet describes the contents of the NEW yoda-metadata.xml which belong to its own new namespace. Consequently, within a stylesheet both the new and old namespaces are required. &lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:yoda=\"https://utrechtuniversity.github.io/yoda-schemas/default\" exclude-result-prefixes=\"yoda\"&gt; &lt;xsl:template match=\"/\"&gt; &lt;xsl:apply-templates select=\"/yoda:metadata\"/&gt; &lt;/xsl:template&gt; &lt;xsl:template match=\"/yoda:metadata\"&gt; &lt;metadata xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"https://utrechtuniversity.github.io/yoda-schemas/default/v2\" xsi:schemaLocation=\"https://utrechtuniversity.github.io/yoda-schemas/default/v2 research.xsd\"&gt; . This last row is what will become the header row that is part of the new yoda-metadata.xml. Thus defining its new default namespace and schemaLocation. ",
    "url": "/yoda/design/metadata/metadata-transformation.html#code",
    "relUrl": "/design/metadata/metadata-transformation.html#code"
  },"173": {
    "doc": "Metadata transformations",
    "title": "Metadata transformations",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-transformation.html",
    "relUrl": "/design/metadata/metadata-transformation.html"
  },"174": {
    "doc": "Metadata vault",
    "title": "Metadata of datasets in the vault",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-vault.html#metadata-of-datasets-in-the-vault",
    "relUrl": "/design/metadata/metadata-vault.html#metadata-of-datasets-in-the-vault"
  },"175": {
    "doc": "Metadata vault",
    "title": "Submit to vault",
    "content": "When requesting a datapackage to be accepted into the vault, its corresponding metadata will be validated first. Validation will take place against the community metadata JSON. If this does not exists, validation will take place against the default metadata JSON of the Yoda instance. ",
    "url": "/yoda/design/metadata/metadata-vault.html#submit-to-vault",
    "relUrl": "/design/metadata/metadata-vault.html#submit-to-vault"
  },"176": {
    "doc": "Metadata vault",
    "title": "Editing metadata in vault",
    "content": "The metadata form is also used for editing of metadata when the data package has already been accepted and copied to the vault. A datamanager, a yoda-user that is member of a datamanager-group for the same research-group, can still edit metadata for the package that is already in the vault. However, the data as originally entered by the researcher and accepted for the vault by a datamanager is never compromised / lost. ",
    "url": "/yoda/design/metadata/metadata-vault.html#editing-metadata-in-vault",
    "relUrl": "/design/metadata/metadata-vault.html#editing-metadata-in-vault"
  },"177": {
    "doc": "Metadata vault",
    "title": "Metadata form for the vault",
    "content": "The presented metadata form within the vault uses the same basic technique(s) as in the dynamic storage space. It uses the same JSON schema as the research area. Therefore, the form layout is identical as shown in the research environment. Also validation of the metadata is identical. Permissions . Only the datamanager of the vault-group is allowed to edit metadata. Presentation . In the vault environment the data presented in the metadata form is loaded from the latest/newest yoda-metadata.json present within the dataset. A vault package contains all (previously) saved metadata-files with an extend suffix between brackets to 1) make its name unique and 2) to see a timeorder . yoda-metadata[1554743001].json yoda-metadata[1554733000].json . IMPORT . The latest vault yoda-metadata file for the datapackage is loaded into PHP. A JSON object is created holding all required data for the frontend. The corresponding JSONSchema (either community or default schema) is required as well to be able to feed the metadataForm. ",
    "url": "/yoda/design/metadata/metadata-vault.html#metadata-form-for-the-vault",
    "relUrl": "/design/metadata/metadata-vault.html#metadata-form-for-the-vault"
  },"178": {
    "doc": "Metadata vault",
    "title": "Saving metadata",
    "content": "The entire process is handled in a similar way like in the research area. Main difference is that the new data is not actually overwriting the data in yoda-metadata.json. The metadata form saves its data in the vault in the corresponding folder but always with a unique name, based upon timestamps. Thus always safeguarding earlier metadata. Presented metadata in vault, is always based upon the newest metadata known for datasets in the vault. Validation . When a datamanager edits data and saves this, the new metadata is validated agains the proper. After posting, the metadata is validated against the metadata JSON schema. ",
    "url": "/yoda/design/metadata/metadata-vault.html#saving-metadata",
    "relUrl": "/design/metadata/metadata-vault.html#saving-metadata"
  },"179": {
    "doc": "Metadata vault",
    "title": "Metadata vault",
    "content": " ",
    "url": "/yoda/design/metadata/metadata-vault.html",
    "relUrl": "/design/metadata/metadata-vault.html"
  },"180": {
    "doc": "Mock tape archive",
    "title": "Mock tape archive",
    "content": "This page describes how to use the mock DMF tape storage. The mock DMF tape storage is installed in Yoda development environments. ",
    "url": "/yoda/development/mock_tape_archive.html",
    "relUrl": "/development/mock_tape_archive.html"
  },"181": {
    "doc": "Mock tape archive",
    "title": "Usage:",
    "content": "Mock DMF tape storage is installed in a virtualenv, active to use it: . $ sudo su irods $ cd ~ $ . dms-archive-mock/tape_archive_venv/bin/activate . Example to add a data object to the tape archive and put it offline: . $ iput -R mockTapeArchive test.json $ dmattr /var/lib/irods/Vault3/home/rods/test.json $ dmput -r /var/lib/irods/Vault3/home/rods/test.json . ",
    "url": "/yoda/development/mock_tape_archive.html#usage",
    "relUrl": "/development/mock_tape_archive.html#usage"
  },"182": {
    "doc": "Mock tape archive",
    "title": "More information",
    "content": "Several of the DMF commands are described here: https://www.nas.nasa.gov/hecc/support/kb/data-migration-facility-(dmf)-commands_250.html . ",
    "url": "/yoda/development/mock_tape_archive.html#more-information",
    "relUrl": "/development/mock_tape_archive.html#more-information"
  },"183": {
    "doc": "Publication Process",
    "title": "Publication Process",
    "content": "All state is kept in key-value-pair *publicationState and persisted into metadata after each step. Configuration is pulled from metadata on the UUSYSTEMCOLLECTION iRODS collection and kept in *publicationConfig. Credentials are pulled from the Yoda credential store (store_config.json). Each step has a rule with the configuration and state as arguments. Temporary collection will be rods owned and located at UUSYSTEMCOLLECTION/publish. Precondition: . | Vault package has APPROVED_FOR_PUBLICATION status | Actor is rodsadmin | . Step 0: Set publicationState.status to PROCESSING . Step 1: Load configuration from UUSYSTEMCOLLECTION . | public server | moai server | Yoda prefix | DataCite prefix | . Step 2: Generate Yoda DOI . | Generate Random ID | set random ID in state | Add prefixes | Set Yoda DOI | . Step 3: Determine Last Modification Time . | Add to State | . Step 4: Generate Combi JSON consisting of user and system metadata . | Save CombiJSON in temporary collection | Add path of CombiJSON to state | . Step 5: Generate DataCite JSON from Combi JSON . | Add DataCite JSON to state | On failure: . | Flag package with unrecoverable failure | Bail | . | . Step 6: Check if DOI is in use . | If in use: . | remove DOI and RandomId from State | Flag package for retry | Bail | . | If not in use: . | Add DOI to metadata of Vault Package | . | . Step 7: Send DataCite JSON . | Retrieve DataCite url and DataCite credentials from credentials store | API request to metadata endpoint with DataCite JSON | put result in state | On request failure: . | Flag package for retry | Bail | . | On metadata incorrect failure: . | Flag package as unrecoverable | Bail | . | . Step 8: Create Landing Page . | Use CombiJSON to generate landing page | Add landing page path to state | On failure: . | Flag package with unrecoverable failure | . | . Step 9: Create Landing Page URL . | Use public host, prefixes and randomId for landing page url (Example: http://public.yoda.uu.nl/i-lab/UU01/Y7B2DD.html) | On failure: . | Should never fail at this stage | . | . Step 10: Secure copy landing page to public server . | Use secure copy to push landing page | On failure: . | Flag package for retry | . | . Step 11: Secure copy metadata for Yoda MOAI server . | Use secure copy to push combi JSON to MOAI server | On failure: . | Flag package for retry | . | . Step 12: Mint DOI with landing page . | API request to DOI end point with landing page url | On failure: . | Flag package for retry | . | . Step 13: the vault package is given PUBLISHED status. ",
    "url": "/yoda/design/processes/publication-process.html",
    "relUrl": "/design/processes/publication-process.html"
  },"184": {
    "doc": "Publication Process",
    "title": "Depublication process",
    "content": "This is very similar to the publication process. The DOI and URLs were preserved in the UUSYSTEMCOLLECTION metadata, and are reused by the depublication process. Depublication is performed with the differences noted below. Precondition: . | Vault package has PENDING_DEPUBLICATION status | Actor is rodsadmin | . Step 2 of the publication process above is skipped. A DOI has already been generated. Step 4: Generate Combi JSON consisting only the system metadata, as the user metadata is being removed. Step 5 and 6 of the publication process above are skipped. Step 7: Remove (i.e. hide) DataCite metadata . | Retrieve DataCite url and DataCite credentials from credentials store | API request to remove metadata from Datacite | put result in state | On request failure: . | Flag package for retry | Bail | . | . Step 9 is skipped, the landing page URL has already been generated. Step 12 is skipped, the DOI at DataCite has already been minted. Step 13: the vault package is given DEPUBLISHED status. ",
    "url": "/yoda/design/processes/publication-process.html#depublication-process",
    "relUrl": "/design/processes/publication-process.html#depublication-process"
  },"185": {
    "doc": "Publication Process",
    "title": "Republication process",
    "content": "The republication process is very similar to the publication process. The DOI and URLs were preserved in the UUSYSTEMCOLLECTION metadata, and are reused by the republication process. Precondition: . | Vault package has PENDING_REPUBLICATION status | Actor is rodsadmin | . Step 13: the vault package is given PUBLISHED status. ",
    "url": "/yoda/design/processes/publication-process.html#republication-process",
    "relUrl": "/design/processes/publication-process.html#republication-process"
  },"186": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Yoda and the iRODS Python Rule Engine Plugin",
    "content": "iRODS can be used with various rule engine plugins, so that rules can be written in multiple programming languages. Yoda uses both the builtin (legacy) iRODS rule language plugin and the Python Rule Engine Plugin (PREP). This page contains basic information about working with the PREP in combination with Yoda. The PREP documentation has additional generic information and examples. ",
    "url": "/yoda/design/other/python-plugin.html",
    "relUrl": "/design/other/python-plugin.html"
  },"187": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Configuring the Python rule engine plugin",
    "content": "The Python Rule Engine Plugin is configured in server_config.json, in the rule_engines array: . { \"instance_name\": \"irods_rule_engine_plugin-python-instance\", \"plugin_name\": \"irods_rule_engine_plugin-python\", \"plugin_specific_configuration\": {} } . The Python plugin is the second element in the rule engine list, after the iRODS rule language plugin, so that we can combine legacy rule language code with new Python code. ",
    "url": "/yoda/design/other/python-plugin.html#configuring-the-python-rule-engine-plugin",
    "relUrl": "/design/other/python-plugin.html#configuring-the-python-rule-engine-plugin"
  },"188": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Python rule functions",
    "content": "There are three different types of functions, each with its own way of handling arguments and return values: . | Rules called directly by iRODS have numbered parameters passed through rule_args: . def acPythonPEP(rule_args, callback, rei): callback.writeLine(\"stdout\", \"arg = \" + rule_args[0]) . Such rules can also return values through numbered output parameters. | Rules called with irule or from the frontend have access to global_vars, in which named parameters are passed as strings including the quotes: . def main(rule_args, callback, rei): arg = global_vars[\"*arg\"][1:-1] # strip the quotes callback.writeLine(\"stdout\", \"arg = \" + arg) . Output cannot be passed back through named parameters, but has to be handled with writeString/writeLine: . INPUT *arg=\"some argument\" OUTPUT ruleExecOut . Note that global_vars is only available to Python rule functions, not to other functions called by rule functions. | Ordinary Python functions which are not called as a rule by iRODS or externally, but only by other Python code. For example: . def concat(str1, str2): return str1 + str2 . | . Explanation of parameters from the PREP documentation: . The first argument [...], rule_args, is a tuple containing the optional, positional parameters fed to the rule function by its caller; these same parameters may be written to, with the effect that the written values will be returned to the caller. The callback object is effectively a gateway through which other rules (even those managed by other rule engine plugins) and microservices may be called. Finally, rei (also known as \"rule execution instance\") is an object carrying iRODS-related context for the current rule call, including any session variables. ",
    "url": "/yoda/design/other/python-plugin.html#python-rule-functions",
    "relUrl": "/design/other/python-plugin.html#python-rule-functions"
  },"189": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Running Python rule code using irule",
    "content": "The example below shows a simple “Hello world” rule that can be executed using irule. The rule takes the name argument from global_vars, strips away the quotes and prints a greeting. def main(rule_args, callback, rei): name = global_vars[\"*name\"][1:-1] callback.writeLine(\"stdout\", \"Hello \" + name + \"!\") input *name=\"World\" output ruleExecOut . The code can be run by putting it in a .r file, e.g. hello.r and then running irule on it: . $ irule -r irods_rule_engine_plugin-python-instance -F hello.r Hello World! . You need to have a rodsadmin account in order to run Python code this way. The rule function needs to be named main. ",
    "url": "/yoda/design/other/python-plugin.html#running-python-rule-code-using-irule",
    "relUrl": "/design/other/python-plugin.html#running-python-rule-code-using-irule"
  },"190": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Defining Python code in the ruleset",
    "content": "iRODS Python code in the ruleset needs to ultimately be imported from /etc/irods/core.py. On Yoda environments, core.py has an import statement that imports all Python code in the Yoda ruleset directory: . from rules_uu import * . Yoda Python rule code is put in ruleset directory /etc/irods/yoda-ruleset, which is linked from /etc/irods/rules_uu. Each rule is defined in a function. This is a minimal example of a rule definition in Python: . def hello_world(rule_args, callback, rei): callback.writeLine(\"stdout\", \"Hello world!\") . If you add this function to a Python file in the ruleset directory, and ensure it is included in the file’s __all__ list (assuming it has one), you can call it using irule: . $ irule -r irods_rule_engine_plugin-python-instance hello_world null ruleExecOut Hello world! . If the rule would have had a parameter, you could have passed it like this: . irule -r irods_rule_engine_plugin-python-instance hello_world '*arg=\"some argument\"' ruleExecOut . ",
    "url": "/yoda/design/other/python-plugin.html#defining-python-code-in-the-ruleset",
    "relUrl": "/design/other/python-plugin.html#defining-python-code-in-the-ruleset"
  },"191": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Using Yoda rule decorators",
    "content": "In Yoda, the rule.make decorator is commonly used to write rules in a more pythonic way and to reduce boilerplate. This example defines a rule with two input parameters and a single output parameter using rule.make: . @rule.make(inputs=[0,1], outputs=[2]) def foo(ctx, x, y): return int(x) + int(y) . This is the equivalent of the code above without the decorator: . def foo(rule_args, callback, rei): x, y = rule_args[0:2] rule_args[2] = int(x) + int(y) . For a complete overview of functionality of rule.make, please consult the function documentation . There’s also an api.make decorator available that creates an API function which can receive and return data in JSON format. For additional information, please consult the function documentation . ",
    "url": "/yoda/design/other/python-plugin.html#using-yoda-rule-decorators",
    "relUrl": "/design/other/python-plugin.html#using-yoda-rule-decorators"
  },"192": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Simple code example roundtrip iRODS -&gt; Python -&gt; iRODS",
    "content": "Essence of the example is that rule_args serves as both input and as output parameters . iRODS rule language: . # \\brief Front end rule to retrieve XSD location # # \\param[in] folder Path of the folder # \\param[out] schemaLocation Location of XSD # \\param[out] status Status of the action # \\param[out] statusInfo Information message when action was not successful iiFrontGetSchemaLocation(*folder, *schemaLocation, *status, *statusInfo) { *status = \"Success\"; *statusInfo = \"\"; *schema = ''; iiRuleGetLocation(*folder, *schema); # it is not possible to directly use *schemaLocation here writeLine('serverLog', 'schema: ' ++ *schema); *schemaLocation = *schema; # again, does not work when passing schemaLocation directly in iiRuleGetLocation } . Python: . # \\brief Nonsense function that returns 'enriched' text based on rule_args[0] # rule_args serves both as input and output parameters def iiRuleGetLocation(rule_args, callback, rei): rule_args[1] = 'You passed the folder: ' + rule_args[0] . ",
    "url": "/yoda/design/other/python-plugin.html#simple-code-example-roundtrip-irods---python---irods",
    "relUrl": "/design/other/python-plugin.html#simple-code-example-roundtrip-irods---python---irods"
  },"193": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Calling microservices from Python code",
    "content": "Use irods_types to create output parameters of the proper type, and obtain the output values from ret_val[\"arguments\"][N]. Example code: . def uuGetGroups(rule_args, callback, rei): import json groups = [] ret_val = callback.msiMakeGenQuery(\"USER_GROUP_NAME\", \"USER_TYPE = 'rodsgroup'\", irods_types.GenQueryInp()) query = ret_val[\"arguments\"][2] # output parameter type GenQueryInp ret_val = callback.msiExecGenQuery(query, irods_types.GenQueryOut()) while True: result = ret_val[\"arguments\"][1] # output parameter type GenQueryOut for row in range(result.rowCnt): name = result.sqlResult[0].row(row) groups.append(name) # continue with this query if result.continueInx == 0: break ret_val = callback.msiGetMoreRows(query, result, 0) callback.writeString(\"stdout\", json.dumps(groups)) . ",
    "url": "/yoda/design/other/python-plugin.html#calling-microservices-from-python-code",
    "relUrl": "/design/other/python-plugin.html#calling-microservices-from-python-code"
  },"194": {
    "doc": "Yoda and the iRODS Python Rule Engine Plugin",
    "title": "Setting AVUs from Python",
    "content": "Example code: . import irods_types def uuMetaAdd(callback, objType, objName, attribute, value): keyValPair = callback.msiString2KeyValPair(attribute + \"=\" + value, irods_types.KeyValPair())['arguments'][1] retval = callback.msiAssociateKeyValuePairsToObj(keyValPair, objName, objType) def addCollectionStatus(rule_args, callback, rei): uuMetaAdd(callback, \"-C\", \"/tempZone/home/research-initial\", \"status\", \"PUBLISHED\") . ",
    "url": "/yoda/design/other/python-plugin.html#setting-avus-from-python",
    "relUrl": "/design/other/python-plugin.html#setting-avus-from-python"
  },"195": {
    "doc": "v0.9.7",
    "title": "Release Notes - Yoda v0.9.7",
    "content": "Version: 0.9.7 . Released: August 2017 . ",
    "url": "/yoda/release-notes/release-0.9.7.html#release-notes---yoda-v097",
    "relUrl": "/release-notes/release-0.9.7.html#release-notes---yoda-v097"
  },"196": {
    "doc": "v0.9.7",
    "title": "What’s new",
    "content": "Features . | Folders in the research area can be secured in the vault | A datamanager per category can approve packages for the vault and control read access within the vault | File modifications can be reverted with the help of revisions | Rules to restore a collection in mass | Introduction of the statistics module | Integration of the youth intake module | . ",
    "url": "/yoda/release-notes/release-0.9.7.html#whats-new",
    "relUrl": "/release-notes/release-0.9.7.html#whats-new"
  },"197": {
    "doc": "v0.9.7",
    "title": "Upgrading from previous release",
    "content": "Install the 0.9.7 version of at least yoda-ruleset and irods-ruleset-research. Install the latest version of implementation specific rulesets; irods-ruleset-youth-cohort or irods-ruleset-i-lab for example . Run the following migration scripts as rodsadmin to enable new features: . /etc/irods/yoda-ruleset/tools/createSystemCollections.r This script creates system collections that are needed for metadata schema’s and revisions. To enabe revisions run it as follows: . irule -F createSystemCollections.r \"*enableRevisions=1\" . /etc/irods/yoda-ruleset/set-vault-permissions.r This scripts makes the vault collections belonging to a research group visible and allows a datamanager to manage read-only access. /etc/irods/irods-ruleset-research/tools/migrate-locks.r The locking mechanism and folder statuses have changed. This script will migrate these to the new situation. /etc/irods/irods-ruleset-research/tools/create-revision-stores.r Existing research groups do not have a revision store. This script will create one and will create an initial revision for every data object found. This could be a long running process. /etc/irods/irods-ruleset-research/tools/install-default-xml-for-metadata.r Only run this script when the default metadata schema hasn’t been installed yet. If the main resource is not named “irodsResc” or if you don’t want to use the “ilab” schema then adapt this call: . irule -F install-default-xml-for-metadata.r '*resc=\"irodsResc\"' '*src=\"/etc/irods/irods-ruleset-research/tools/xml\"' '*default=\"ilab\"' . Update the portal by pulling in the 0.9.7 version of the yoda-portal, yoda-portal-group-manager, yoda-portal-research, yoda-portal-statistics and if applicable the youth intake portal module. Copy the cronjobs cronjon-revision-cleanup.sh and copy-accepted-folders-to-vault.r to /var/lib/irods/.irods and add them to the crontab like the example below. 0,5,10,15,20,25,30,35,40,45,50,55 * * * * /bin/irule -F $HOME/.irods/job_movetovault.r &gt;&gt;$HOME/iRODS/server/log/job_movetovault.log 2&gt; /dev/null 0 0 * * * /bin/sh $HOME/.irods/cronjob-revision-cleanup.sh &gt;&gt; $HOME/iRODS/server/log/cronjob-revision-cleanup.log 2&gt; /dev/null */2 * * * * /bin/irule -F $HOME/.irods/copy-accepted-folders-to-vault.r &gt;&gt; $HOME/iRODS/server/log/copy-accepted-folders-to-vault.log . To workaround a memory leak in the irodsReServer iRODS needs to be restarted regularly. The restartifirodsisidle.sh script from the yoda-ruleset/tools directory is meant to restart iRODS only if no jobs are running. It could be included in a cronjob or invoked by monit using irodsReServer.monit also found in the yoda-ruleset/tools directory. ",
    "url": "/yoda/release-notes/release-0.9.7.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-0.9.7.html#upgrading-from-previous-release"
  },"198": {
    "doc": "v0.9.7",
    "title": "Known Issues",
    "content": ". | With the research ruleset loaded we see occasional glibc level errors in the logs. They have no noticeable impact on the user. | The iRODS server will get slower over time due to a memory leak. A workaround is suggested above in the upgrade section. | When storage data is available, different tiers are assigned, and all resources are then reset to the same tier, the statistics module may show a blank page. | . ",
    "url": "/yoda/release-notes/release-0.9.7.html#known-issues",
    "relUrl": "/release-notes/release-0.9.7.html#known-issues"
  },"199": {
    "doc": "v0.9.7",
    "title": "v0.9.7",
    "content": " ",
    "url": "/yoda/release-notes/release-0.9.7.html",
    "relUrl": "/release-notes/release-0.9.7.html"
  },"200": {
    "doc": "v1.0",
    "title": "Release Notes - Yoda v1.0",
    "content": "Version: 1.0 . Released: November 2017 . ",
    "url": "/yoda/release-notes/release-1.0.html#release-notes---yoda-v10",
    "relUrl": "/release-notes/release-1.0.html#release-notes---yoda-v10"
  },"201": {
    "doc": "v1.0",
    "title": "What’s new",
    "content": "Features . | Researchers can submit a datapackage in the vault for publication after confirming the terms and agreements | Datamanagers can approve the submit for publication | The license text of a published datapackage is stored in the vault (license.txt) | Datamanagers can update metadata of datapackages in the vault | Anonymous users can view the landingpage of a published datapackage. The DOI (and link to the landingpage) is available on https://mds.datacite.org/ | Anonymous users can access ‘open access’ publications using the link on the landingpage. browser or webdav | A subset of the metadata is published on https://mds.datacite.org/ , the landingpage and the moai server | Harvesters can get the last modified date of the published record of a datapackage on the moai server | Folders and datapackages have a provenance action log with historical information of the actions, the user that initiated the action with date and time | Published datapackages in the vault provide system metadata with package size, doi, landingpage uri | Metadata supports hierarchical constructs, replication of fields and constructs, compound fields (when filled all fields have to be filled) | Datapackages in the vault have different statuses, search for status has been extended accordingly | All regular users of a research group have read access, by default, to the group’s datapackages in the vault. The datamanager can revoke group access. | Searching is no longer case sensitive | All members of a group can view the groups storage consumption and trends using the statistics module | . ",
    "url": "/yoda/release-notes/release-1.0.html#whats-new",
    "relUrl": "/release-notes/release-1.0.html#whats-new"
  },"202": {
    "doc": "v1.0",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.4.x). No migrations required. | yoda-metadata.xsd is changed. Existing 0.9.7 metadata is not supported and needs to be updated manually | publication functionality requires a datamanager group and datamanager user for a category and the datamanager group folder must exist | Ansible can be used for deployment and updates | terms and agreement text files (html) have to be installed by the administrator. The most recent file will be used | license files (e.g. CC-BY.txt), with the license text and uri files (e.g. “https://creativecommons.org/licenses/by/4.0/legalcode” have to be installed by the administrator | default XSD, schema-for-formelements.xsd, schema-for-xsd.xsd, XML, default.xsl, default2landingpage.xsl and default2datacite.xsl have to be installed by the administrator | . ",
    "url": "/yoda/release-notes/release-1.0.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.0.html#upgrading-from-previous-release"
  },"203": {
    "doc": "v1.0",
    "title": "Known Issues",
    "content": ". | when the datamanager saves updated metadata in the vault, the portal shows the old metadata. Saving the changes in the vault takes at most 1 minute. Close and re-open the metadata to see if your changes are shown, before taking further actions (e.g. approve for publication) | The iRODS server will get slower over time due to a memory leak. A workaround is suggested above in the upgrade section. iRODS 4.1.11 (included is Yoda 1.0) may have solved this problem. | When storage data is available, different tiers are assigned, and all resources are then reset to the same tier, the statistics module may show a blank page | Ordering of data in tables is not working. Clicking column sort headers have been disabled and are not shown. | . ",
    "url": "/yoda/release-notes/release-1.0.html#known-issues",
    "relUrl": "/release-notes/release-1.0.html#known-issues"
  },"204": {
    "doc": "v1.0",
    "title": "v1.0",
    "content": " ",
    "url": "/yoda/release-notes/release-1.0.html",
    "relUrl": "/release-notes/release-1.0.html"
  },"205": {
    "doc": "v1.1",
    "title": "Release Notes - Yoda v1.1",
    "content": "Version: 1.1 . Released: March 2018 . ",
    "url": "/yoda/release-notes/release-1.1.html#release-notes---yoda-v11",
    "relUrl": "/release-notes/release-1.1.html#release-notes---yoda-v11"
  },"206": {
    "doc": "v1.1",
    "title": "What’s new",
    "content": "Features . | Update metadata of published packages in the vault | Copying data packages from vault to research area | Add support for flexible date fields to metadata form | Add support for geo location fields to metadata form | Prevent parallel execution of the same background process | Default data access is set to restricted | Fix incorrect access rights after folder move | Fix incorrect pagination in research area | Fix incorrect creator name in intake module | Upgrade CodeIgniter to 3.1.7 | . ",
    "url": "/yoda/release-notes/release-1.1.html#whats-new",
    "relUrl": "/release-notes/release-1.1.html#whats-new"
  },"207": {
    "doc": "v1.1",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.5.x). No migrations required. ",
    "url": "/yoda/release-notes/release-1.1.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.1.html#upgrading-from-previous-release"
  },"208": {
    "doc": "v1.1",
    "title": "Known Issues",
    "content": ". | When storage data is available, different tiers are assigned, and all resources are then reset to the same tier, the statistics module may show a blank page | Ordering of data in tables is not working. Clicking column sort headers have been disabled and are not shown. | . ",
    "url": "/yoda/release-notes/release-1.1.html#known-issues",
    "relUrl": "/release-notes/release-1.1.html#known-issues"
  },"209": {
    "doc": "v1.1",
    "title": "v1.1",
    "content": " ",
    "url": "/yoda/release-notes/release-1.1.html",
    "relUrl": "/release-notes/release-1.1.html"
  },"210": {
    "doc": "v1.2",
    "title": "Release Notes - Yoda v1.2",
    "content": "Version: 1.2 . Released: May 2018 . ",
    "url": "/yoda/release-notes/release-1.2.html#release-notes---yoda-v12",
    "relUrl": "/release-notes/release-1.2.html#release-notes---yoda-v12"
  },"211": {
    "doc": "v1.2",
    "title": "What’s new",
    "content": "Features . | Depublication of published packages in the vault | Republication of depublished packages in the vault | New frontpage for Yoda Data Publication platform | Fix replications of deleted data objects | Fix multiple X-Frame-Options headers | Fix flexdate client side validation | . ",
    "url": "/yoda/release-notes/release-1.2.html#whats-new",
    "relUrl": "/release-notes/release-1.2.html#whats-new"
  },"212": {
    "doc": "v1.2",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.5.x). No migrations required. ",
    "url": "/yoda/release-notes/release-1.2.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.2.html#upgrading-from-previous-release"
  },"213": {
    "doc": "v1.2",
    "title": "Known Issues",
    "content": ". | Ordering of data in tables is not working. Clicking column sort headers have been disabled and are not shown. | . ",
    "url": "/yoda/release-notes/release-1.2.html#known-issues",
    "relUrl": "/release-notes/release-1.2.html#known-issues"
  },"214": {
    "doc": "v1.2",
    "title": "v1.2",
    "content": " ",
    "url": "/yoda/release-notes/release-1.2.html",
    "relUrl": "/release-notes/release-1.2.html"
  },"215": {
    "doc": "v1.3",
    "title": "Release Notes - Yoda v1.3",
    "content": "Version: 1.3 . Released: November 2018 . ",
    "url": "/yoda/release-notes/release-1.3.html#release-notes---yoda-v13",
    "relUrl": "/release-notes/release-1.3.html#release-notes---yoda-v13"
  },"216": {
    "doc": "v1.3",
    "title": "What’s new",
    "content": "Features . | Upgrade from iRODS 4.1.11 to 4.2.4 | Persistent identifier (EPIC-PID) for vault packages | Data folder is now unlocked after securing it in in the vault | CSV export in Statistics module for Yoda admin | Data classification for groups added to the Group Manager | Usability improvements in the Group Manager | DataCite format support for the OAI-PMH service | Email notifications when a package is published | Several performance and security improvements | . ",
    "url": "/yoda/release-notes/release-1.3.html#whats-new",
    "relUrl": "/release-notes/release-1.3.html#whats-new"
  },"217": {
    "doc": "v1.3",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.7.x). No migrations required. Make sure the delayed rule queue is empty before upgrading (iqstat -a). Add the following fields to the Ansible environment files (see yoda/CONFIGURATION.md for description): . | yoda_environment (replaces codeigniter_environment) | credential_files | send_notifications | notifications_sender_email | notifications_reply_to | smtp_server | smtp_username | smtp_password | epic_url | epic_handle_prefix | . ",
    "url": "/yoda/release-notes/release-1.3.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.3.html#upgrading-from-previous-release"
  },"218": {
    "doc": "v1.3",
    "title": "v1.3",
    "content": " ",
    "url": "/yoda/release-notes/release-1.3.html",
    "relUrl": "/release-notes/release-1.3.html"
  },"219": {
    "doc": "v1.4",
    "title": "Release Notes - Yoda v1.4",
    "content": "Version: 1.4 . Released: December 2018 . ",
    "url": "/yoda/release-notes/release-1.4.html#release-notes---yoda-v14",
    "relUrl": "/release-notes/release-1.4.html#release-notes---yoda-v14"
  },"220": {
    "doc": "v1.4",
    "title": "What’s new",
    "content": "Features . | Upgrade to iRODS 4.2.5 | Support for external users through the External User Service | Data package access rights published to DataCite and OAI-PMH | Performance improvements for the Intake module. Note: if a study shows unscanned files, please scan again. | Extended Zabbix monitoring of Yoda | UX improvements to the login form | Several performance and security improvements | Option to configure EPIC credentials inside Ansible environment files | Added script to report, and optionally fix, bad ACLs for revisions. | . ",
    "url": "/yoda/release-notes/release-1.4.html#whats-new",
    "relUrl": "/release-notes/release-1.4.html#whats-new"
  },"221": {
    "doc": "v1.4",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.7.x). No migrations required. Add the following fields to the Ansible environment files (see yoda/CONFIGURATION.md for description): . | yoda_eus_fqdn | epic_key (base64 encoded) | epic_cert (base64 encoded) | eus_api_fqdn | eus_api_secret | eus_db_password | eus_smtp_host | eus_smtp_port | eus_smtp_user | eus_smtp_password | eus_smtp_from_address | eus_smtp_replyto_address | eus_mail_template | repo_only (optional, YAML boolean) | . ",
    "url": "/yoda/release-notes/release-1.4.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.4.html#upgrading-from-previous-release"
  },"222": {
    "doc": "v1.4",
    "title": "v1.4",
    "content": " ",
    "url": "/yoda/release-notes/release-1.4.html",
    "relUrl": "/release-notes/release-1.4.html"
  },"223": {
    "doc": "v1.5",
    "title": "Release Notes - Yoda v1.5",
    "content": "Version: 1.5 . Released: July 2019 . ",
    "url": "/yoda/release-notes/release-1.5.html#release-notes---yoda-v15",
    "relUrl": "/release-notes/release-1.5.html#release-notes---yoda-v15"
  },"224": {
    "doc": "v1.5",
    "title": "What’s new",
    "content": "Features . | New metadata form based on JSON schema | Research and vault space are split into separate modules | Add support for upload and download (25MB up / unlimited download) | Add support for viewing media in the portal | Support for metadata schema identifiers and schema migrations | Check for unpreservable file formats in your datasets | Configurable number of records in file browser | Several UX improvements to the research space | Portal performance improvements (upgrade to PHP 7.2) | Upgrade CodeIgniter framework to latest release (v3.1.10) | Additional monitoring items for Zabbix | Script to check vault data integrity | . Bug Fixes . | Fixed: CSV exports start with an empty row | Fixed: unsubmit after submit fails in some cases | . Known limitations . | Assumes default-0 compliant XSD schema. | . ",
    "url": "/yoda/release-notes/release-1.5.html#whats-new",
    "relUrl": "/release-notes/release-1.5.html#whats-new"
  },"225": {
    "doc": "v1.5",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.7.x). Requires Yoda public server and external user service to be on version 1.4.x or higher. | Set Yoda release to release-1.5 in configuration. | Add vault module to portal modules configuration. | Instance specific rulesets (e.g. irods-ruleset-i-lab) are merged with yoda-ruleset and should be removed from the configuration (rulesets). | Rename default metadata schema from default to default-0 in the configuration (ensure update_schemas is enabled). | Run the Ansible upgrade in check mode. | Run the Ansible upgrade. | Add a schema identifier to all metadata on the system: irule -F /etc/irods/irods-ruleset-research/tools/check-metadata-for-schema-updates.r . All metadata touched will be logged in the rodsLog. Adding the schema identifiers can take some time, the batch script adds 256 jobs per 60 seconds to the rule queue. | Check if all metadata on the system has a schema identifier: irule -F /etc/irods/irods-ruleset-research/tools/check-metadata-for-identifier.r . | Update all landingpages with the new layout (if there are published packages): irule -F /etc/irods/irods-ruleset-research/tools/update-landingpages.r . | . ",
    "url": "/yoda/release-notes/release-1.5.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.5.html#upgrading-from-previous-release"
  },"226": {
    "doc": "v1.5",
    "title": "Customization after upgrade (optional)",
    "content": ". | The Ansible playbook installs default lists of preservable file formats. If you need to add any custom lists, follow the procedure for installing lists of preservable file formats | . ",
    "url": "/yoda/release-notes/release-1.5.html#customization-after-upgrade-optional",
    "relUrl": "/release-notes/release-1.5.html#customization-after-upgrade-optional"
  },"227": {
    "doc": "v1.5",
    "title": "v1.5",
    "content": " ",
    "url": "/yoda/release-notes/release-1.5.html",
    "relUrl": "/release-notes/release-1.5.html"
  },"228": {
    "doc": "v1.6",
    "title": "Release Notes - Yoda v1.6",
    "content": "Version: 1.6 . Released: November 2020 . ",
    "url": "/yoda/release-notes/release-1.6.html#release-notes---yoda-v16",
    "relUrl": "/release-notes/release-1.6.html#release-notes---yoda-v16"
  },"229": {
    "doc": "v1.6",
    "title": "What’s new",
    "content": "Features . | Improved folder browsing and sorting browse list | Create folders from web portal | Rename and remove files and folders from web portal | Increase upload limit (300MB) | Metadata format changed from XML to JSON | Add support for geo location in metadata schemas | Add support for datarequest module (installation instructions) | New tool to check mail configuration | Upgrade to iRODS v4.2.7 | Deprecate support for TLS 1.0 and TLS 1.1 (use legacy_tls flag to enable support for TLS 1.0 and TLS 1.1) | . Known issues . The transformation of metadata, often required when a new version of Yoda is deployed holding one or more metadataschema changes versions, can not be completed when metadata still is in locked state “ACCEPTED”. Therefore, the appointed admin needs to run checks beforehand and settles unfinished workflows to avoid incomplete metadata transformation(s). ",
    "url": "/yoda/release-notes/release-1.6.html#whats-new",
    "relUrl": "/release-notes/release-1.6.html#whats-new"
  },"230": {
    "doc": "v1.6",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.9.x). Requires Yoda external user service to be on version 1.5.x or higher. Requires Yoda public server to be on version 1.6.x or higher. | Set Yoda release to release-1.6 in configuration. yoda_version: release-1.6 . | Set the default schema to default-1 in configuration. default_yoda_schema: default-1 . | The core modules (research, vault, statistics, group-manager) are enabled by default in Yoda 1.6. Only extra modules have to be enabled in the configuration. So modules becomes extra_modules and all core modules should be removed from the extra_modules list. Update the configuration according to your specifications. For example: # Yoda modules extra_modules: - name: intake repo: \"https://github.com/UtrechtUniversity/yoda-portal-intake.git\" dest: /var/www/yoda/yoda-portal/modules/intake version: \"\\{\\{ yoda_version \\}\\}\" . | The core rulesets (core and yoda-ruleset) are enabled by default in Yoda 1.6. Only extra modules have to be enabled in the configuration. Furthermore, the research ruleset (irods-ruleset-research) has been merged with the UU ruleset (yoda-ruleset). So rulesets becomes extra_rulesets; core, irods-ruleset-research and yoda-ruleset should be removed from the extra_rulesets list. Update the configuration according to your specifications. For example: # iRODS rulesets extra_rulesets: - name: irods-ruleset-youth-cohort repo: https://github.com/UtrechtUniversity/irods-ruleset-youth-cohort.git ruleset_name: rules-yc version: \"\\{\\{ yoda_version \\}\\}\" install_scripts: no . | Run the Ansible playbook in check mode. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml --check ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml --check . | If the playbook has finished succesfully in check mode, run the Ansible playbook normally. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml . | Convert all metadata XML in the vault to JSON (default-0 XML to default-0 JSON). irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/check-vault-metadata-xml-for-transformation-to-json.r . | Update all metadata JSON in the vault to latest metadata JSON version (default-0 to default-1). irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/check-metadata-for-schema-updates.r . | Update publication endpoints if there are published packages (landingpages and OAI-PMH)): irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/update-publications.r . | . ",
    "url": "/yoda/release-notes/release-1.6.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.6.html#upgrading-from-previous-release"
  },"231": {
    "doc": "v1.6",
    "title": "v1.6",
    "content": " ",
    "url": "/yoda/release-notes/release-1.6.html",
    "relUrl": "/release-notes/release-1.6.html"
  },"232": {
    "doc": "v1.7",
    "title": "Release Notes - Yoda v1.7",
    "content": "Version: 1.7 . Released: May 2021 . ",
    "url": "/yoda/release-notes/release-1.7.html#release-notes---yoda-v17",
    "relUrl": "/release-notes/release-1.7.html#release-notes---yoda-v17"
  },"233": {
    "doc": "v1.7",
    "title": "What’s new",
    "content": "Features . | Theming capability for all available Yoda modules using Bootstrap 4 | Support for MFA login on the web portal using OIDC | API access for all currently used functionality used by the Yoda frontend for all modules | Landingpage support for specific metadata forms (HPTlab and Teclab) for Utrecht University Geo Faculty | The CC-0 (Creative Commons zero) license is added to allow publishing data under this license | Test script for administrators to send a tests email, so email settings can be tested | Script for administrators to update all published datapackages endpoints (DataCite, landingpages and OAI-PMH) | . Known issues . | When datapackage is secured to the vault, and directly after the metadata is edited and saved in the research area, the file metadata.json will be shown twice for a brief period of time (&lt;5 minutes) | . ",
    "url": "/yoda/release-notes/release-1.7.html#whats-new",
    "relUrl": "/release-notes/release-1.7.html#whats-new"
  },"234": {
    "doc": "v1.7",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.9.x). Requires Yoda external user service to be on version 1.5.x or higher. Requires Yoda public server to be on version 1.6.x or higher. | Checkout branch release-1.7 of the Yoda Git repository. git checkout release-1.7 . | Set Yoda release to release-1.7 in configuration. yoda_version: release-1.7 . | Run the Ansible playbook in check mode. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml --check ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml --check . | If the playbook has finished successfully in check mode, run the Ansible playbook normally. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml . | Update publication endpoints if there are published packages (DataCite, landingpages and OAI-PMH): irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/update-publications.r . | . ",
    "url": "/yoda/release-notes/release-1.7.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.7.html#upgrading-from-previous-release"
  },"235": {
    "doc": "v1.7",
    "title": "v1.7",
    "content": " ",
    "url": "/yoda/release-notes/release-1.7.html",
    "relUrl": "/release-notes/release-1.7.html"
  },"236": {
    "doc": "v1.8",
    "title": "Release Notes - Yoda v1.8",
    "content": "Version: 1.8 . Released: July 2022 . ",
    "url": "/yoda/release-notes/release-1.8.html#release-notes---yoda-v18",
    "relUrl": "/release-notes/release-1.8.html#release-notes---yoda-v18"
  },"237": {
    "doc": "v1.8",
    "title": "What’s new",
    "content": "Features . | Full theming support | Support for Data Access Passwords | Support for user settings | Support for notifications | Support for copy and move actions in the web portal | Support for multi-select actions for files and folders in research space | Support for davrods server on separate host | Support for Data Package References | Support for checksum reports | Support for local Postfix MTA | Improvements to default schema (default-2) | Transformation from default-1 to teclab-0 / hptlab-0 | Improved search module and new search bar in header | Improved search functionality in group manager | Added Mailpit for easier mail testing during development | DataCite connection uses REST API instead of legacy MDS | Several UX improvements to default theme | Upgrade iRODS to v4.2.11 | Upgrade python-irodsclient to v1.1.3 | Removed legacy_tls flag (legacy TLS support, TLS 1.0 and 1.1) | . Known issues . | Collections with single apex “’” in the name do not work irods/irods#5727 | Deadlock in msiDataObjRepl &amp; msiDataObjCopy when called from Python irods_rule_engine_plugin_python#54 | . ",
    "url": "/yoda/release-notes/release-1.8.html#whats-new",
    "relUrl": "/release-notes/release-1.8.html#whats-new"
  },"238": {
    "doc": "v1.8",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.9.x). Requires Yoda external user service to be on version 1.5.x or higher. Requires Yoda public server to be on version 1.6.x or higher. | Backup/copy custom configurations made to Yoda version 1.7. To view what files were changed from the defaults, run git diff. | After making sure the configurations are stored safely in another folder, reset the Yoda folder using git stash or when you want to delete all changes made: git reset --hard. | Checkout branch release-1.8 of the Yoda Git repository. git checkout release-1.8 . | Set the Yoda version to release-1.8 in the configuration. yoda_version: release-1.8 . | Change the default schema from default-1 to default-2 in the configuration. Discipline must be present in all vault packages before migration. I.e. discipline must be manually added if not present yet. This requires an intervention by the responsible datamanager beforehand. default_yoda_schema: default-2 . | Two OpenID Connect configuration options have been added and one has been replaced. If OIDC is active (oidc_active), make sure you have configured, oidc_jwks_uri and oidc_jwt_issuer. Option oidc_domain is replaced with oidc_domains. Example: oidc_domains: ['domain1.tld', 'domain2.tld'] . | DataCite connection is now using REST API instead of legacy MDS. If DataCite is configured, the option datacite_server should be replaced with datacite_rest_api_url. Example: datacite_rest_api_url: api.test.datacite.org . | Install all Ansible collections needed to deploy Yoda: ansible-galaxy collection install -r requirements.yml . | Run the Ansible playbook in check mode. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml --check ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml --check . | If the playbook has finished successfully in check mode, run the Ansible playbook normally. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml . | Update all metadata JSON in the vault to latest metadata JSON version (default-1 to default-2). irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/check-metadata-for-schema-updates.r . | Update publication endpoints if there are published packages (DataCite, landingpages and OAI-PMH): irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/update-publications.r . | If the data request module is enabled, project managers, data managers and data committee members will only continue to receive emails regarding data requests if they have notifications enabled. The imeta command can be used to check whether a user has notifications enabled, and enable them if needed: | . imeta ls -u u.user@uu.nl org_settings_mail_notifications imeta set -u u.user@uu.nl org_settings_mail_notifications IMMEDIATE . | If the data request module is enabled, manually update the data request module schemas after upgrading (replace ZONENAME with the zone name of the environment): | . /etc/irods/yoda-ruleset/tools/install-datarequest-schemas.sh ZONENAME . ",
    "url": "/yoda/release-notes/release-1.8.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.8.html#upgrading-from-previous-release"
  },"239": {
    "doc": "v1.8",
    "title": "v1.8",
    "content": " ",
    "url": "/yoda/release-notes/release-1.8.html",
    "relUrl": "/release-notes/release-1.8.html"
  },"240": {
    "doc": "v1.9",
    "title": "Release Notes - Yoda v1.9",
    "content": "Version: 1.9 . Released: TBA . ",
    "url": "/yoda/release-notes/release-1.9.html#release-notes---yoda-v19",
    "relUrl": "/release-notes/release-1.9.html#release-notes---yoda-v19"
  },"241": {
    "doc": "v1.9",
    "title": "What’s new",
    "content": "Features . | Support for DOI versioning | Support for configuring metadata schemas per research group | Support for configuring retention period per research group | Support for basic controlled vocabularies in metadata schemas | Support for Data Access Passwords expiration notifications | Support for research group retention period notifications | Support for multiple replication resources | Support for configuring iRODS S3 resources | Upgrade python-irodsclient to v1.1.5 | . Known issues . | Collections with single apex “’” in the name do not work irods/irods#5727 | Deadlock in msiDataObjRepl &amp; msiDataObjCopy when called from Python irods_rule_engine_plugin_python#54 | . ",
    "url": "/yoda/release-notes/release-1.9.html#whats-new",
    "relUrl": "/release-notes/release-1.9.html#whats-new"
  },"242": {
    "doc": "v1.9",
    "title": "Upgrading from previous release",
    "content": "Upgrade is supported by Ansible (2.11.x). Requires Yoda external user service to be on version 1.8.x or higher. Requires Yoda public server to be on version 1.8.x or higher. | Backup/copy custom configurations made to Yoda version 1.8. To view what files were changed from the defaults, run git diff. | After making sure the configurations are stored safely in another folder, reset the Yoda folder using git stash or when you want to delete all changes made: git reset --hard. | Checkout branch release-1.9 of the Yoda Git repository. git checkout release-1.9 . | Set the Yoda version to release-1.9 in the configuration. yoda_version: release-1.9 . | Install all Ansible collections needed to deploy Yoda: ansible-galaxy collection install -r requirements.yml . | Run the Ansible playbook in check mode. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml --check ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml --check . | If the playbook has finished successfully in check mode, run the Ansible playbook normally. ansible-playbook -i &lt;path-to-your-environment&gt; playbook.yml ### EXAMPLE ### ansible-playbook -i /environments/development/allinone playbook.yml . | Update all metadata JSON in the vault to latest metadata JSON version (default-1 to default-2). irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/check-metadata-for-schema-updates.r . | Update publication endpoints if there are published packages (DataCite, landingpages and OAI-PMH): irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/update-publications.r . | . ",
    "url": "/yoda/release-notes/release-1.9.html#upgrading-from-previous-release",
    "relUrl": "/release-notes/release-1.9.html#upgrading-from-previous-release"
  },"243": {
    "doc": "v1.9",
    "title": "v1.9",
    "content": " ",
    "url": "/yoda/release-notes/release-1.9.html",
    "relUrl": "/release-notes/release-1.9.html"
  },"244": {
    "doc": "Research space",
    "title": "Research space",
    "content": " ",
    "url": "/yoda/design/overview/research-space.html",
    "relUrl": "/design/overview/research-space.html"
  },"245": {
    "doc": "Research space",
    "title": "Introduction",
    "content": "The research space is described in this document. The state diagram documents the states and transitions of a folder in the research space. The sequence diagram documents the interactions between the actors in the research space. ",
    "url": "/yoda/design/overview/research-space.html#introduction",
    "relUrl": "/design/overview/research-space.html#introduction"
  },"246": {
    "doc": "Research space",
    "title": "State diagram",
    "content": ". ",
    "url": "/yoda/design/overview/research-space.html#state-diagram",
    "relUrl": "/design/overview/research-space.html#state-diagram"
  },"247": {
    "doc": "Research space",
    "title": "Sequence diagram",
    "content": ". ",
    "url": "/yoda/design/overview/research-space.html#sequence-diagram",
    "relUrl": "/design/overview/research-space.html#sequence-diagram"
  },"248": {
    "doc": "Restore collection",
    "title": "Restore collection",
    "content": "If you want to restore a collection you can use the restore-collection.r tool from the yoda-ruleset. The tool is located at /etc/irods/yoda-ruleset/tools/restore-collection.r . The tool accepts the following parameters: . | Parameter | Description | . | path | Path to collection to restore | . | timestamp | UNIX timestamp, restore collection to revision from before this timestamp | . | restorePath | Path to restore the collection to, empty if you want to restore in the same collection | . ",
    "url": "/yoda/administration/restore-collection.html",
    "relUrl": "/administration/restore-collection.html"
  },"249": {
    "doc": "Restore collection",
    "title": "Examples:",
    "content": "irule -r irods_rule_engine_plugin-irods_rule_language-instance -F restore-collection.r \"*path='/tempZone/home/research-test'\" \"*timestamp=1540819891\" . Restore the collection /tempZone/home/research-test with revision before 1540819891 (Mon Oct 29 14:31:31 2018 CET). irule -r irods_rule_engine_plugin-irods_rule_language-instance -F restore-collection.r \"*path='/tempZone/home/research-test'\" \"*timestamp=1540819891\" \"*restorePath='/tempZone/home/research-test/restore'\" . Restore the collection /tempZone/home/research-test with revision before 1540819891 (Mon Oct 29 14:31:31 2018 CET) into collection /tempZone/home/research-test/restore. ",
    "url": "/yoda/administration/restore-collection.html#examples",
    "relUrl": "/administration/restore-collection.html#examples"
  },"250": {
    "doc": "Revision management",
    "title": "Revision management",
    "content": "For each new file or file modification Yoda creates a timestamped backup file in the revision store. The revision store is located at /tempZone/yoda/revisions. ",
    "url": "/yoda/design/processes/revisions.html",
    "relUrl": "/design/processes/revisions.html"
  },"251": {
    "doc": "Revision management",
    "title": "Revision strategies",
    "content": "Not all revisions are kept, only a predefined number of revisions are being kept per time bucket. A time bucket is a time offset from now into the past. Each revision strategy has a predefined set of time buckets and number of revisions stored in those buckets. Strategy A: . | time bucket | number of revisions | . | 6 hours | 1 | . | 12 hours | 1 | . | 18 hours | 1 | . | 1 day | 1 | . | 2 days | 1 | . | 3 days | 1 | . | 4 days | 1 | . | 5 days | 1 | . | 6 days | 1 | . | 1 week | 1 | . | 2 weeks | 1 | . | 3 weeks | 1 | . | 4 weeks | 1 | . | 8 weeks | 1 | . | 12 weeks | 1 | . | 16 weeks | 1 | . Strategy B: . | time bucket | number of revisions | . | 12 hours | 2 | . | 1 day | 2 | . | 3 days | 2 | . | 5 days | 2 | . | 1 week | 2 | . | 3 weeks | 2 | . | 8 weeks | 2 | . | 16 weeks | 2 | . Strategy Simple: . | time bucket | number of revisions | . | 16 weeks | 5 | . ",
    "url": "/yoda/design/processes/revisions.html#revision-strategies",
    "relUrl": "/design/processes/revisions.html#revision-strategies"
  },"252": {
    "doc": "Setting job flags",
    "title": "Setting job flags",
    "content": "The replication and revision jobs can be graciously stopped by setting a flag. When these flags are set, iRODS-level changes can be performed without having to kill these jobs (which can potentially cause inconsistencies / unexpected problems). The jobs check for the presence a flag before processing each data object. If it is present, the job stops and logs a message that it is stopped. ",
    "url": "/yoda/administration/setting-job-flags.html",
    "relUrl": "/administration/setting-job-flags.html"
  },"253": {
    "doc": "Setting job flags",
    "title": "Replication flag",
    "content": "Set: . itouch /tempZone/yoda/flags/stop_replication . Unset: . irm /tempZone/yoda/flags/stop_replication . ",
    "url": "/yoda/administration/setting-job-flags.html#replication-flag",
    "relUrl": "/administration/setting-job-flags.html#replication-flag"
  },"254": {
    "doc": "Setting job flags",
    "title": "Revisions flag",
    "content": "Set: . itouch /tempZone/yoda/flags/stop_revisions . Unset: . irm /tempZone/yoda/flags/stop_revisions . ",
    "url": "/yoda/administration/setting-job-flags.html#revisions-flag",
    "relUrl": "/administration/setting-job-flags.html#revisions-flag"
  },"255": {
    "doc": "Setting up development environment",
    "title": "Setting up development environment",
    "content": "Setting up a Yoda development environment is easy, you only need the following: . | VirtualBox or libvirt | Vagrant (&gt;= 2.0) | . On GNU/Linux or macOS you also need: . | Ansible (&gt;= 2.11) | . The guide below will deploy an ‘allinone’ instance (all functional roles in one virtual machine) with the default configuration. | Clone the Yoda repository and checkout the development branch: git clone https://github.com/UtrechtUniversity/yoda.git cd yoda git checkout development . | Configure the virtual machines for development: vagrant up . | On a Windows host first SSH into the Ansible controller virtual machine (skip this step on GNU/Linux or macOS): vagrant ssh controller cd ~/yoda . On a GNU/Linux or macOS host make sure the SSH keys have the right permissions (skip this step on Windows): . chmod 0600 ~/yoda/vagrant/ssh/vagrant . | Deploy Yoda to the virtual machines: ansible-galaxy collection install -r requirements.yml ansible-playbook -i environments/development/allinone/ playbook.yml . | Add following hosts to /etc/hosts (GNU/Linux or macOS) or %SystemRoot%\\System32\\drivers\\etc\\hosts (Windows): 192.168.56.10 portal.yoda.test 192.168.56.10 data.yoda.test 192.168.56.10 public.data.yoda.test 192.168.56.10 public.yoda.test 192.168.56.10 eus.yoda.test . | Provision Yoda with test data: ansible-playbook -i environments/development/allinone/ test.yml . | [OPTIONAL] Provision Yoda with Zabbix agent and monitoring scripts: . Configure Zabbix server in environments/development/allinone/group_vars/allinone.yml and make sure a Zabbix server is running on this address, you could use a Zabbix appliance in Virtualbox. zabbix_server: 192.168.56.20 . Run the Zabbix playbook . ansible-playbook -i environments/development/allinone/ zabbix.yml . | . ",
    "url": "/yoda/development/setting-up-development-environment.html",
    "relUrl": "/development/setting-up-development-environment.html"
  },"256": {
    "doc": "Setting up development environment",
    "title": "Upgrading your Yoda development environment",
    "content": "Upgrading the Yoda development environment to the latest version can be done by running the Ansible playbooks again. | On a Windows host first SSH into the Ansible controller virtual machine (skip this step on GNU/Linux or macOS): vagrant ssh controller cd ~/yoda . | Upgrade Ansible scripts: git pull . | Upgrade Yoda development environment: ansible-playbook -i environments/development/allinone/ playbook.yml . | . ",
    "url": "/yoda/development/setting-up-development-environment.html#upgrading-your-yoda-development-environment",
    "relUrl": "/development/setting-up-development-environment.html#upgrading-your-yoda-development-environment"
  },"257": {
    "doc": "Setting up development environment",
    "title": "Development environment test users and data",
    "content": "When you have set up an Yoda development environment and provisioned it with test data the following users are created: . | User | Role | . | viewer | Viewer with read only access to research groups | . | researcher | Researcher with read / write access to research groups | . | groupmanager | Groupmanager with user management rights on research groups | . | datamanager | Datamanager of the research groups | . | technicaladmin | Technical administrator with rodsadmin access | . Password for all test users is test. In research group research-initial a folder testdata is created with some example data. ",
    "url": "/yoda/development/setting-up-development-environment.html#development-environment-test-users-and-data",
    "relUrl": "/development/setting-up-development-environment.html#development-environment-test-users-and-data"
  },"258": {
    "doc": "Setting up development environment",
    "title": "Surf development environment",
    "content": "Surf uses the following setup: . | Portal server: runs Yoda portal, iRODS iCAT server (provider), iCAT database and EUS | WebDAV server: runs DavRODS and public server, as well as iRODS resource server (consumer) | Resource server: additional iRODS resource server | . To deploy it on local VMs, add the following entries to your hosts file: . # Surf Yoda test 192.168.56.20 portal.surfyoda.test 192.168.56.21 data.surfyoda.test 192.168.56.21 public.data.surfyoda.test 192.168.56.21 public.surfyoda.test 192.168.56.20 eus.surfyoda.test 192.168.56.22 resource.surfyoda.test . And run the following commands in the root of the Yoda repository: . cp vagrant/environment/surf/Vagrantfile . vagrant box update vagrant up ansible-playbook -DK -i environments/development/surf playbook.yml . ",
    "url": "/yoda/development/setting-up-development-environment.html#surf-development-environment",
    "relUrl": "/development/setting-up-development-environment.html#surf-development-environment"
  },"259": {
    "doc": "Statistics module",
    "title": "Statistics module",
    "content": " ",
    "url": "/yoda/design/overview/statistics.html",
    "relUrl": "/design/overview/statistics.html"
  },"260": {
    "doc": "Statistics module",
    "title": "Resources and tiers",
    "content": "Any resources can be administratively assigned to one tier. A tier is an Yoda introduced entity, not standard iRODS A tier can be considered a price level of a resource. metadata on resource level:org_storage_tier = ‘tape’ . If no tier is assigned to a resource yet, this is considered the ‘Standard’ tier by default. ",
    "url": "/yoda/design/overview/statistics.html#resources-and-tiers",
    "relUrl": "/design/overview/statistics.html#resources-and-tiers"
  },"261": {
    "doc": "Statistics module",
    "title": "Registering usage data",
    "content": "Once a month a cronjob registers storage data for each category, based upon each group in the category. Collection of storage amount is performed per group and per storage tier and stored as metadata on corresponding group. When collection fails the storage data of the previoues month is used as fallback. All determined storage data is recorded on group level. Each group holds the following metadata with key: org_storage_data_month. This is postfixed with the month number, like: . org_storage_data_month01 org_storage_data_month02 org_storage_data_month03 org_storage_data_month04 org_storage_data_month05 org_storage_data_month06 org_storage_data_month07 org_storage_data_month08 org_storage_data_month09 org_storage_data_month10 org_storage_data_month11 org_storage_data_month12 . Thus creating a full year cyclic buffer. Per entry, i.e. for a group every month, each metadata-entry holds category, tier and  storage information in a JSON format ['Categoryname', 'Tiername', '100']. The frontend steps into this cyclic buffer starting from current month backward. Per month the front end gets tiername and storage data in a total array divided in tiername, months and storage. Metadata attribute: UUORGMETADATAPREFIX ++ 'storage_data_month' ++ *month; . Metadata value: *json_str = \"[\\\"*category\\\", \\\"*tier\\\", \\\"*storageAmount\\\"]\"; . The corresponding category is registered on group level as well as a group could possibly change category. So for historic purposes it is required to know to what category a group belonged. ",
    "url": "/yoda/design/overview/statistics.html#registering-usage-data",
    "relUrl": "/design/overview/statistics.html#registering-usage-data"
  },"262": {
    "doc": "Statistics module",
    "title": "Twelve month registration",
    "content": "Per group one or more metadata attributes like this exist for a month. This occurs for each month (org_storageDataMonth01, … , org_storageDataMonth12) thus setting up a cyclic buffer for registration with a maximum history 12 months history. After 12 months the previous values are overwritten automatically by the monthly cronjob. ",
    "url": "/yoda/design/overview/statistics.html#twelve-month-registration",
    "relUrl": "/design/overview/statistics.html#twelve-month-registration"
  },"263": {
    "doc": "Statistics module",
    "title": "Collecting data for reporting",
    "content": "To find all latest and historic data for a category metadata can be matched against ‘[\\“’ ++ *cat ++ ‘\\”%%’. This will bring up all metadata storage metadata for this category. Combined with a specific month this will bring up all required data to calculate the storage per tier for a specific category for a month. ",
    "url": "/yoda/design/overview/statistics.html#collecting-data-for-reporting",
    "relUrl": "/design/overview/statistics.html#collecting-data-for-reporting"
  },"264": {
    "doc": "Statistics module",
    "title": "Which month does registered data belong to?",
    "content": "Registration takes place on the first day of a month, the data collected is linked to that month. I.e. data collected on 1st of June is linked to the month of June. And therefore registered under org_storage_data_month06. ",
    "url": "/yoda/design/overview/statistics.html#which-month-does-registered-data-belong-to",
    "relUrl": "/design/overview/statistics.html#which-month-does-registered-data-belong-to"
  },"265": {
    "doc": "Theme packaging",
    "title": "Theme packaging",
    "content": " ",
    "url": "/yoda/design/overview/theme-packages.html",
    "relUrl": "/design/overview/theme-packages.html"
  },"266": {
    "doc": "Theme packaging",
    "title": "Overriding the default templates and static files with user defined themes",
    "content": "Yoda allows for developers to add themes to the default (Utrecht University) theme. Thus adding the possibility for developers to tweak a Yoda instance to their own look and feel. Adding themes can be accomplished by overriding the default templates and static files that are supplied within the default (Utrecht University) Yoda. Overriding can be done on two levels: 1) Template (HTML) overriding 2) Static (css/img/js) overriding . ",
    "url": "/yoda/design/overview/theme-packages.html#overriding-the-default-templates-and-static-files-with-user-defined-themes",
    "relUrl": "/design/overview/theme-packages.html#overriding-the-default-templates-and-static-files-with-user-defined-themes"
  },"267": {
    "doc": "Theme packaging",
    "title": "Templates in Yoda",
    "content": "In the default setup, based on a modularly constructed flask environment, the required html templates are organized as follows: . /var/www/yoda     /general/templates/general/*.html     /module_name/templates/module_name/*.html . in which the general directory holds all basic html files, for instance the foundation of the application, in which the modules can reside. ",
    "url": "/yoda/design/overview/theme-packages.html#templates-in-yoda",
    "relUrl": "/design/overview/theme-packages.html#templates-in-yoda"
  },"268": {
    "doc": "Theme packaging",
    "title": "Overriding templates (HTML)",
    "content": "flask.cfg holds the yoda theme (filled by ansible but can be manually overridden): e.g. YODA_THEME = ‘vu’ YODA_THEME_PATH = ‘/var/www/yoda/themes’ . When building a webpage yoda software first looks into the yoda/themes/vu directory whether a requested template is placed at that location. If so, this will be used (thus overriding the default supplied template). If not, the software will use the default template as supplied in the default (Utrecht University) situation. The structure under yoda/themes/vu must be the same as the default structure as well as the template names must be the same. E.g.: . /var/yoda/themes     /uu1         /general/base.html         /research/browse.html     … .     /uu2         /research/revision.html         /vault/browse.html     … . In the above example following default HTML files will be overridden when uu1 or uu2 is selected as a theme: . For uu1: /var/www/yoda/general/templates/general/base.html /var/www/yoda/research/templates/research/browse.html . For uu2: /var/www/yoda/research/templates/research/revision.html /var/www/yoda/vault/templates/vault/browse.html . ",
    "url": "/yoda/design/overview/theme-packages.html#overriding-templates-html",
    "relUrl": "/design/overview/theme-packages.html#overriding-templates-html"
  },"269": {
    "doc": "Theme packaging",
    "title": "Override static files (js, img, css)",
    "content": "To change the appearance or user experience on the frontend it is necessary to be able to override static files as supplied with yoda. This is only possible when the blueprint files are equipped with a different static_url_path . stats_bp = Blueprint(‘stats_bp’, __name__,                                   template_folder=’templates’,                                   static_folder=’static/stats’,                                   static_url_path=’/assets’) . On application level, in app.py, the static folder is set to ‘assets’ as well: app = Flask(__name__, static_folder=’assets’) . When the frontend requests for url’s holding the keyword ‘assets’ it will check whether the set theme holds the requested static file according to following structure: . /var/yoda/themes      /uu1         /static/css             /js/…         /research/static                 /css/..                 /js/..         /vault/static/img/…     /uu2         /static/css/         /research/static/js/ . If the requested file is not found, the default (Utrecht University) static file will be used. General level url request: requested url = /assets/css/yoda-portal.css . When present, /yoda/themes/uu1/static/css/yoda-portal.css is returned. If not present fall back to default, /yoda/static/css/yoda-portal.css is returned . Modular level url request: requested url = /research/assets/css/research.css . When present, /yoda/themes/uu1/research/static/css/yoda-portal.css is returned. If not present fall back to default /yoda/research/static/research/css/yoda-portal.css is returned . ",
    "url": "/yoda/design/overview/theme-packages.html#override-static-files-js-img-css",
    "relUrl": "/design/overview/theme-packages.html#override-static-files-js-img-css"
  },"270": {
    "doc": "Theme packaging",
    "title": "Resulting theme package structure",
    "content": "Putting templates and css together results in following theme package structure . /uu1     /static/css/…     /research         /template.html         /static/css/…             /js/…             /img/…     … /uu2     /static/css/…     /research         /template.html         /static/css/…             /js/…             /img/…     … /vu     /static/css/…     /research         /template.html         /static/css/…             /js/…             /img/…     … . ",
    "url": "/yoda/design/overview/theme-packages.html#resulting-theme-package-structure",
    "relUrl": "/design/overview/theme-packages.html#resulting-theme-package-structure"
  },"271": {
    "doc": "Theme packaging",
    "title": "Compiling theme CSS",
    "content": "Building theme CSS: . sudo su yodadeployment cd /var/www/yoda-portal/static/src/ # Install npm nvm install v16 # Install sass compiler npm install npm install -g sass # Build (default) UU theme sass --style compressed build_uu.scss ../../static/css/yoda-portal.css # Build (custom) VU theme sass --style compressed build_vu.scss ../../themes/vu/static/css/yoda-portal.css . ",
    "url": "/yoda/design/overview/theme-packages.html#compiling-theme-css",
    "relUrl": "/design/overview/theme-packages.html#compiling-theme-css"
  },"272": {
    "doc": "Theme packaging",
    "title": "DavRODS theming",
    "content": "DavRODS uses different theming logic than the portal. By default, it uses the themed logo of the portal. The logo is linked to the UU website. Use the yoda_davrods_logo_path and yoda_davrods_logo_link parameters to change this behaviour. For more advanced changes, it will be necessary to customize the DavRODS layout templates. ",
    "url": "/yoda/design/overview/theme-packages.html#davrods-theming",
    "relUrl": "/design/overview/theme-packages.html#davrods-theming"
  },"273": {
    "doc": "Troubleshooting email",
    "title": "How to troubleshoot email-related issues",
    "content": "In order to verify that sending email messages from Yoda works as expected, an email test script is included in the yoda-ruleset repository. It can be called from the command line as the irods user. For example: . /etc/irods/yoda-ruleset/tools/mail/mail-test.sh \"a.admin@uu.nl\" . The expected output is: . Successfully executed rule for testing email with destination &lt;a.admin@uu.nl&gt; . You should shortly receive an email message on the provided address with subject [Yoda] Test mail. ",
    "url": "/yoda/administration/troubleshooting-email.html#how-to-troubleshoot-email-related-issues",
    "relUrl": "/administration/troubleshooting-email.html#how-to-troubleshoot-email-related-issues"
  },"274": {
    "doc": "Troubleshooting email",
    "title": "Postfix",
    "content": "If you have configured Yoda to use Postfix for email delivery, additional information is logged for troubleshooting. In that case, email delivery log data can be found in /var/log/maillog. The current contents of the Postfix mail queue can be viewed using the sudo postqueue -p command. ",
    "url": "/yoda/administration/troubleshooting-email.html#postfix",
    "relUrl": "/administration/troubleshooting-email.html#postfix"
  },"275": {
    "doc": "Troubleshooting email",
    "title": "Troubleshooting email",
    "content": " ",
    "url": "/yoda/administration/troubleshooting-email.html",
    "relUrl": "/administration/troubleshooting-email.html"
  },"276": {
    "doc": "Troubleshooting publication",
    "title": "How to deal with hanging publications",
    "content": "When a publication stays in Approved status for an extended period of time (longer than cronjob interval) something probably went wrong. Here are some troubleshooting hints. First look for process_publication (v1.8.5 or earlier) or [publication] (v1.9.0 or later) in /var/lib/irods/log/rodsLog. It will show the processing of the publication. | When a publication succeeds it will return status OK. | When the publication process has caught an error, but has no recovery process it will return Unrecoverable as status. | When the whole process was interrupted at a time the error could not be caught, the status will stay at Processing. | When the publication process encountered a DOI collision it will set status to Retry and reset the generated random ID. | When the publication process encounters connectivity problems with DataCite or the public server it will set the status to Retry. | . Then look at the rodsLog around the time of the problem. Error messages could give you a hint on the root cause. The publication process saves its state in metadata on the vault package. You can use imeta to list the details. See an example below. imeta lsw -C /tempZone/home/vault-test/research-test[123456789] org_publication% . When the problem is caused by invalid metadata, check the value of org_publication_combiJsonPath and org_publication_dataCiteJsonPath. You can use iget to download the generated metadata at these paths and check for JSON related problems. When the org_publication_status is Retry the publication process will be retried until success. Check status.datacite.org if you suspect a DataCite problem. Publications will fail if the API servers are down. Check the ability of the rods user to set up a ssh connection with the inbox user on the public Yoda server. When troubleshooting was successful the publication process will skip the subtasks before the failure and continue. When the org_publication_status is Processing and the root cause of the crash looks to be incidental, you could set the status to Retry with imeta on the org_publication_status. The publication will be retried the next time the cronjob runs. imeta set -C /tempZone/home/vault-test/research-test[123456789] org_publication_status Retry . The publication rule can be set to verbose mode so that it logs additional information for troubleshooting purposes. In order to enable this, set the org_publication_verbose_mode AVU on the system collection: . imeta set -C /tempZone/yoda org_publication_verbose_mode yes . After troubleshooting, verbose mode can be disabled by removing the org_publication_verbose_mode AVU. When the org_publication_status is Unrecoverable then one of JSON conversion steps have produced invalid metadata. You could use a third party JSON processor on the metadata in the previously mentioned source JSON files with the used JSON schemas from the current category / research group. This could tell you the problem. If the metadata generation succeeds but is still invalid according to the DataCite API, you could use an JSON validator on the DataCite JSON using the version 4 schemas found at schema.datacite.org. ",
    "url": "/yoda/administration/troubleshooting-publication.html#how-to-deal-with-hanging-publications",
    "relUrl": "/administration/troubleshooting-publication.html#how-to-deal-with-hanging-publications"
  },"277": {
    "doc": "Troubleshooting publication",
    "title": "Troubleshooting publication",
    "content": " ",
    "url": "/yoda/administration/troubleshooting-publication.html",
    "relUrl": "/administration/troubleshooting-publication.html"
  },"278": {
    "doc": "Troubleshooting replication and revision creation",
    "title": "Troubleshooting replication and revision creation",
    "content": "Revision creation and replication of data objects are handled asynchronously. Policies add metadata attributes to data objects that need to be replicated or have a new revision. The replication and revision creation cronjobs process these data objects asynchronously. Generic information about these background jobs can be found on the page about background processes. This page contains advice regarding how to troubleshoot these processes. If a data object is not replicated or does not get a new revision, consider first stopping and temporarily disabling the background process cronjob for troubleshooting. This can be done by temporarily setting the background process stop flag (/ZONE/yoda/flags/stop_replication or /ZONE/yoda/flags/stop_revisions) and waiting for the job to finish. The iquest command can be used to print a list of data objects that are queued for replication or revision creation. Example for replication: . iquest \"%s/%s\" --no-page \"SELECT COLL_NAME, DATA_NAME where META_DATA_ATTR_NAME = 'org_replication_scheduled'\" . If it seems that the background job is failing, or a data object is not getting processed despite having the expected metadata attribute, you could run the background job in verbose mode. Remember to remove the stop flag of the process first; otherwise the background job will not start. If many data objects (or large data objects) are queued for replication or revision creation it may be advisable to run the job in a tmux session. Running the jobs in verbose mode will log additional information about data objects being processed to the rodsLog. Example command for the replication job: . /bin/python /etc/irods/yoda-ruleset/tools/async-data-replicate.py -v . Failures during revision creation are often caused by permission problems. First run the cron job in verbose mode to determine which data object is causing the problem. Then verify that the data object is accessible to the rods account, e.g. using an iget command. ",
    "url": "/yoda/administration/troubleshooting-replication-revisions.html",
    "relUrl": "/administration/troubleshooting-replication-revisions.html"
  },"279": {
    "doc": "Upgrading metadata schemas",
    "title": "Upgrading metadata schemas",
    "content": "Metadata schemas of an Yoda instance can be migrated to newer version or other metadata schema if a transformation exists. Only metadata in the vault space is upgraded using the steps below. For all metadata in the research space the systems requests the user to transform the metadata to the new metadata schema. | Upgrade default metadata schema using Ansible or manually . | After the upgrade all metadata on the system needs to be migrated, this can be done by running the following command: . irule -r irods_rule_engine_plugin-irods_rule_language-instance -F /etc/irods/yoda-ruleset/tools/check-metadata-for-schema-updates.r . All metadata touched will be logged in the rodsLog. Adding the schema identifiers can take some time, the batch script adds 256 jobs per 60 seconds to the rule queue. | . ",
    "url": "/yoda/administration/upgrading-metadata-schemas.html",
    "relUrl": "/administration/upgrading-metadata-schemas.html"
  },"280": {
    "doc": "To vault process in research module",
    "title": "To vault process in research module",
    "content": "This document does not fully describe the process to push datapackages to the vault. Only the technical choices made to implement the process are described here. The process is described in the architectural state model. ",
    "url": "/yoda/design/processes/vault-process.html",
    "relUrl": "/design/processes/vault-process.html"
  },"281": {
    "doc": "To vault process in research module",
    "title": "Folder status",
    "content": "Each folder in the research area is initialized without any status information. This is regarded as the folder status Folder. Every other status is defined by the metadata field org_status on the collection. The valid statuses and transitions are defined in iiConstant like below. # \\brief All research folder states. FOLDER = \"\"; LOCKED = \"LOCKED\"; SUBMITTED = \"SUBMITTED\"; ACCEPTED = \"ACCEPTED\"; REJECTED = \"REJECTED\"; SECURED = \"SECURED\"; # \\constant IIFOLDERTRANSITIONS IIFOLDERTRANSITIONS = list((FOLDER, LOCKED), (FOLDER, SUBMITTED), (LOCKED, FOLDER), (LOCKED, SUBMITTED), (SUBMITTED, FOLDER), (SUBMITTED, ACCEPTED), (SUBMITTED, REJECTED), (REJECTED, LOCKED), (REJECTED, FOLDER), (REJECTED, SUBMITTED), (ACCEPTED, SECURED), (SECURED, LOCKED), (SECURED, FOLDER), (SECURED, SUBMITTED)) . ",
    "url": "/yoda/design/processes/vault-process.html#folder-status",
    "relUrl": "/design/processes/vault-process.html#folder-status"
  },"282": {
    "doc": "To vault process in research module",
    "title": "Status Policies",
    "content": "All the status transitions are handled by rules in iiFolderStatusTransistions.r. Basically they set the org_status of the folder to the new status and PEP’s in iiPolicies.r will check if the transition is legal and call pre and post procedures for each transition. The checks if a status transition is allowed are found in iiPolicyChecks.r. The pre and post conditions are run based on the manipulation of the org_status metadata. This means every status transition can be triggered with the imeta command. Illegal transitions will be blocked with msiOprDisallowed. ",
    "url": "/yoda/design/processes/vault-process.html#status-policies",
    "relUrl": "/design/processes/vault-process.html#status-policies"
  },"283": {
    "doc": "To vault process in research module",
    "title": "Datamanager approval",
    "content": "When a datamanager is present, a datapackage submitted to the vault by a researcher will remain in the submitted state. The datamanager can approve or reject the package for further processing. A researcher also has the opportunity to unsubmit the package. Because a datamanager only has read access to the research area, he/she cannot edit the org_status directly. To work around this issue the sudo microservices are used to temporarily enable the datamanager to set the org_status to ‘ACCEPTED’ or ‘REJECTED’. The rules can be found in iiDatamanagerPolicies.r and iiSudoPolicies.r. A research group without a datamanager can submit packages to the vault directly. Any submitted folder will be transitioned to ‘ACCEPTED’ state immediately after submission. ",
    "url": "/yoda/design/processes/vault-process.html#datamanager-approval",
    "relUrl": "/design/processes/vault-process.html#datamanager-approval"
  },"284": {
    "doc": "To vault process in research module",
    "title": "Copy to vault",
    "content": "The copy-accepted-folders-to-vault.r cronjob in the tools directory of the research ruleset will copy any folder in ‘ACCEPTED’ state to the vault and set it to ‘SECURED’ state when successful. The copy is done recursively using the uuTreeWalk rule starting from the the ‘ACCEPTED’ folder. The metadata will be copied as well. ",
    "url": "/yoda/design/processes/vault-process.html#copy-to-vault",
    "relUrl": "/design/processes/vault-process.html#copy-to-vault"
  },"285": {
    "doc": "To vault process in research module",
    "title": "Research vault",
    "content": "For each research group a vault group with a vault collection is created. Only the rodsadmin will be a member. This folder is read-only for managers and normal users of the research group. When a datamanager group for the category is present it will get read-only access as well. Inheritance is switched off. This makes it possible to manage permissions for each vault package separately. A datamanager gets control over it. ",
    "url": "/yoda/design/processes/vault-process.html#research-vault",
    "relUrl": "/design/processes/vault-process.html#research-vault"
  },"286": {
    "doc": "To vault process in research module",
    "title": "Granting and revoking read access to the vault for the research group",
    "content": "The datamanager is allowed to use the sudo microservice msiSudoObjAclSet to grant and revoke read access to packages in the vault. This is configured in iiSudoPolicies.r and iiDatamanagerPolicies.r to not interfere with existing sudo policies in the yoda-ruleset. The only action the datamanager is allowed to do is set permissions starting from the root of a vault package to read for the research group with the same basename as the vault. ",
    "url": "/yoda/design/processes/vault-process.html#granting-and-revoking-read-access-to-the-vault-for-the-research-group",
    "relUrl": "/design/processes/vault-process.html#granting-and-revoking-read-access-to-the-vault-for-the-research-group"
  },"287": {
    "doc": "To vault process in research module",
    "title": "No datamanager",
    "content": "When there is no datamanager is present the permissions can only be managed by the rodsadmin. Read-only for the research group by default could be implemented. ",
    "url": "/yoda/design/processes/vault-process.html#no-datamanager",
    "relUrl": "/design/processes/vault-process.html#no-datamanager"
  },"288": {
    "doc": "Vault space",
    "title": "Vault space",
    "content": " ",
    "url": "/yoda/design/overview/vault-space.html",
    "relUrl": "/design/overview/vault-space.html"
  },"289": {
    "doc": "Vault space",
    "title": "Introduction",
    "content": "The vault space is described in this document. The state diagram documents the states and transitions of a folder in the vault space. The sequence diagram documents the interactions between the actors in the vault space. ",
    "url": "/yoda/design/overview/vault-space.html#introduction",
    "relUrl": "/design/overview/vault-space.html#introduction"
  },"290": {
    "doc": "Vault space",
    "title": "State diagram",
    "content": ". ",
    "url": "/yoda/design/overview/vault-space.html#state-diagram",
    "relUrl": "/design/overview/vault-space.html#state-diagram"
  },"291": {
    "doc": "Vault space",
    "title": "Sequence diagram",
    "content": ". ",
    "url": "/yoda/design/overview/vault-space.html#sequence-diagram",
    "relUrl": "/design/overview/vault-space.html#sequence-diagram"
  },"292": {
    "doc": "Wall of Fame",
    "title": "Wall of Fame",
    "content": "This is a list (in alphabetic order and not complete) of contributors to Yoda. Thanks goes to these wonderful people! . | Jurgen AlebregtseUntil 11/2018 | Felix A. Croes Until 07/2019 | Roy van Elk Active | Paul Frederiks Until 01/2018 | . | Rick van de Hoef Active | Hans Kleinloog Until 07/2019 | Jan de Mooij Until 08/2016 | Harm de Raaff Active | . | Chris Smeele Until 08/2020 | Ton Smeele Until 03/2021 | Lazlo Westerhof Active | . ",
    "url": "/yoda/development/wall-of-fame.html",
    "relUrl": "/development/wall-of-fame.html"
  },"293": {
    "doc": "Yoda MOAI service",
    "title": "Yoda MOAI service",
    "content": " ",
    "url": "/yoda/design/overview/yoda-moai.html",
    "relUrl": "/design/overview/yoda-moai.html"
  },"294": {
    "doc": "Yoda MOAI service",
    "title": "Overview",
    "content": ". ",
    "url": "/yoda/design/overview/yoda-moai.html#overview",
    "relUrl": "/design/overview/yoda-moai.html#overview"
  },"295": {
    "doc": "Yoda MOAI service",
    "title": "Yoda MOAI",
    "content": "MOAI offers harvesting functionality following the OAI-PMH standard with the flexibility to serve different metadata prefixes. Currently, Dublin Core and DataCite are implemented as a metadata prefix. ",
    "url": "/yoda/design/overview/yoda-moai.html#yoda-moai",
    "relUrl": "/design/overview/yoda-moai.html#yoda-moai"
  },"296": {
    "doc": "Yoda MOAI service",
    "title": "Provisioning MOAI database",
    "content": "When publishing datasets from within Yoda, the corresponding yoda-metadata.json is put in a location where the Yoda MOAI service can read and process it. Each 5 minutes (configurable) the indicated folder is scanned and newly published JSON files are provisioned to the internal SQLite database. The data is prepared in the database as such that it is able to provide output in JSON form, on request of a harvester. Any OAI-PMH harvester able to read the Dublin Core and DataCite format is able to harvest Yoda through the endpoint serviced by MOAI. ",
    "url": "/yoda/design/overview/yoda-moai.html#provisioning-moai-database",
    "relUrl": "/design/overview/yoda-moai.html#provisioning-moai-database"
  },"297": {
    "doc": "Yoda MOAI service",
    "title": "Yoda MOAI Technical",
    "content": "Provision from Yoda . Python -&gt; yoda.py The script reads all yoda-metadata.json files that have been published and are placed in a specific folder. After processing it puts the found content into the Yoda MOAI SQLite database. ‘Collection name’ as metadata for a dataset A collection name defines an umbrella for different datasets to belong together. By exposing collection names through MOAI, it is possible for a harvester to draw conclusions regarding datasets from the same data supplier about datasets that belong together. Thus, multiple datasets can setup a collection having the same ‘purpose’. The nature of this purpose can be defined by the researchers/datamanagers themselves. In theory, equivalent collection names can exist over multiple Yoda instances. Even within the same Yoda instance. No validation is performed by Yoda software itself. So there is no formal safeguarding/protection of the content of collection name. Harvesters should be (made) aware of that. Initially they should combine collections endpoint/collection . select * from sets; select * from records; . Deliver metadata in datacite format to harvesters . python -&gt; datacite.py Prepares the output data in such a way that the application data of Yoda, originally held in yoda-metadata.json files, can be outputted to an JSON response with DataCite as a metadata prefix. ",
    "url": "/yoda/design/overview/yoda-moai.html#yoda-moai-technical",
    "relUrl": "/design/overview/yoda-moai.html#yoda-moai-technical"
  },"298": {
    "doc": "Setting up YodaDrive development environment",
    "title": "YodaDrive Development Environment",
    "content": "This document describes setting up a development environment for YodaDrive. YodaDrive is a WebDAV driver for Windows, written in C#. Development of YodaDrive requires a Windows development environment with Visual Studio Community 2017 or better. ",
    "url": "/yoda/development/yodadrive-development-environment.html#yodadrive-development-environment",
    "relUrl": "/development/yodadrive-development-environment.html#yodadrive-development-environment"
  },"299": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Virtual Machine",
    "content": "A Windows development environment, if not already available, can be installed on a virtual machine in Azure (Standard B2ms, 2 CPUs, 8 GB memory) or another cloud provider. If creating a VM in the cloud, make sure to restrict RDP access by IP address, or the machine will be hacked in short order even when kept fully up-to-date. ",
    "url": "/yoda/development/yodadrive-development-environment.html#virtual-machine",
    "relUrl": "/development/yodadrive-development-environment.html#virtual-machine"
  },"300": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Visual Studio",
    "content": "Visual Studio Community 2019 is sufficient for development of YodaDrive, since YodaDrive is open source. Make sure that the following components are included for installation: . | .NET Desktop Development | .NET Framework 4.6.1 development tools | . ",
    "url": "/yoda/development/yodadrive-development-environment.html#visual-studio",
    "relUrl": "/development/yodadrive-development-environment.html#visual-studio"
  },"301": {
    "doc": "Setting up YodaDrive development environment",
    "title": "WinFsp",
    "content": "WinFsp is a FUSE-like driver for Windows, which is required by YodaDrive. The version to install is 2019.3 B2 or later, and must match the version used by YodaDrive. WinFsp must be installed manually. Installing it as part of YodaDrive is not sufficient, since the Developer option must be selected during installation. ",
    "url": "/yoda/development/yodadrive-development-environment.html#winfsp",
    "relUrl": "/development/yodadrive-development-environment.html#winfsp"
  },"302": {
    "doc": "Setting up YodaDrive development environment",
    "title": "YodaDrive",
    "content": "Within VS2019, clone from https://github.com/UtrechtUniversity/YodaDrive.git. Then open the KS2Drive.sln solution. ",
    "url": "/yoda/development/yodadrive-development-environment.html#yodadrive",
    "relUrl": "/development/yodadrive-development-environment.html#yodadrive"
  },"303": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Development",
    "content": "YodaDrive is an open source project, which inherits from KS2.Drive. Main development takes part on the development branch. Everything specific to YodaDrive is on the feature/yoda-rebranding branch. When buiding a YodaDrive release, switch to the feature/yoda-rebranding branch, merge the latest changes from the development branch if needed, and update the version number in About/About.xaml. ",
    "url": "/yoda/development/yodadrive-development-environment.html#development",
    "relUrl": "/development/yodadrive-development-environment.html#development"
  },"304": {
    "doc": "Setting up YodaDrive development environment",
    "title": "WinFsp dependency files for YodaDrive distributable",
    "content": "The distributable for YodaDrive can be made to automatically install the proper version of WinFsp as part of the installation process. In order to build the distributable properly, the following has to be done first: . | checkout branch feature/yoda-rebranding | copy the Reference/WinFsp*_* folder to C:\\Program Files (x86)\\Microsoft SDKs\\ClickOnce Bootstrapper\\Packages . | reboot the machine | start Visual Studio | verify that WinFsp is listed among the requirements for publication | . ",
    "url": "/yoda/development/yodadrive-development-environment.html#winfsp-dependency-files-for-yodadrive-distributable",
    "relUrl": "/development/yodadrive-development-environment.html#winfsp-dependency-files-for-yodadrive-distributable"
  },"305": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Developer code signing",
    "content": "The YodaDrive distributable should be signed with the appropriate code signing key. The person in charge of this can install the key within Visual Studio, so that it can automatically sign releases thereafter. ",
    "url": "/yoda/development/yodadrive-development-environment.html#developer-code-signing",
    "relUrl": "/development/yodadrive-development-environment.html#developer-code-signing"
  },"306": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Publication",
    "content": "Publication will generate Application Files, KS2Drive.application and setup.exe in the output directory C:\\OutputKS2Drive. These can then be archived in a ZIP file for distribution. ",
    "url": "/yoda/development/yodadrive-development-environment.html#publication",
    "relUrl": "/development/yodadrive-development-environment.html#publication"
  },"307": {
    "doc": "Setting up YodaDrive development environment",
    "title": "Setting up YodaDrive development environment",
    "content": " ",
    "url": "/yoda/development/yodadrive-development-environment.html",
    "relUrl": "/development/yodadrive-development-environment.html"
  },"308": {
    "doc": "YodaDrive",
    "title": "YodaDrive",
    "content": "YodaDrive is a WebDAV client for Windows, allowing the user to mount a remove WebDAV server as a local drive. YodaDrive is derived from KS2.Drive written by Francois Karam, and depends on WinFsp written by Bill Zissimopoulos. YodaDrive is a C# Visual Studio project, making use of the WebDAVClient library written by Itay Sagui (originally by Kees van den Broek). YodaDrive has been optimized for iRODS servers accessed via davrods, but can be used for any WebDAV server. ",
    "url": "/yoda/design/other/yodadrive.html",
    "relUrl": "/design/other/yodadrive.html"
  },"309": {
    "doc": "YodaDrive",
    "title": "Limitations",
    "content": "Since the remote file system is WebDAV, changes that originate elsewhere are not visible until the user refreshes the view. YodaDrive does not implement WebDAV locking. ",
    "url": "/yoda/design/other/yodadrive.html#limitations",
    "relUrl": "/design/other/yodadrive.html#limitations"
  },"310": {
    "doc": "YodaDrive",
    "title": "Mode of operation",
    "content": "After a remote filesystem has been mounted, calls are made from Windows via WinFsp to Open, Create, Read, Write or Close files. YodaDrive handles Read and Write asynchronously, and all other calls synchronously. For asynchronous Read and Write calls, YodaDrive returns STATUS_PENDING and later performs a callback when the Read or Write completes. Closing a file with pending Write calls will wait for all scheduled writes to complete, before the Close call returns. YodaDrive uses one connection for downloads, and at most two connections for uploads. Read . Downloads for all files in a remote filesystem are all managed on the same connection, with interleaved blocks for Read calls. Each Read call is translated into a separate GET request. Write . Uploads are captured in a single PUT request if possible, as long as all Write calls address consecutive blocks. Each PUT request uses chunked mode, and blocks written are appended as chunks. The initial Write call does not have to address a block at the beginning of the file. At most two uploads can be active at one time. Since consecutive writes are captured in a single PUT request, uploading two large files will prevent any other uploads for the duration. This is handled by postponing Create and Write calls until an upload connection becomes available; Create will pretend to succeed and Write will not have a callback until the actual block could be appended. ReadDirectory . ReadDirectory is performed synchronously, but makes use of the download connection and can be blocked by pending asynchronous Read calls. Note that WinFsp permits ReadDirectory itself to be asynchronous, but we do not implement it as such. ",
    "url": "/yoda/design/other/yodadrive.html#mode-of-operation",
    "relUrl": "/design/other/yodadrive.html#mode-of-operation"
  },"311": {
    "doc": "YodaDrive",
    "title": "State Diagrams",
    "content": ". ",
    "url": "/yoda/design/other/yodadrive.html#state-diagrams",
    "relUrl": "/design/other/yodadrive.html#state-diagrams"
  },"312": {
    "doc": "Running API and UI tests",
    "title": "Running API and UI tests",
    "content": "# Running API and UI tests Yoda uses [pytest](https://pytest.org) for API and UI tests. ## Running tests on the allinone VM In order to run the tests on the Vagrant-based development environment, the allinone (default) Vagrant configuration automatically mounts the `/etc/irods/yoda-ruleset` directory in the VM on the ./test directory. To run the tests on the Vagrant VM: 1. Ensure that you have [Geckodriver](https://github.com/mozilla/geckodriver) installed for running the UI tests. 2. Deploy the VM, for example: ```bash vagrant box update && vagrant up && ansible-playbook -DK -i environments/development/allinone playbook.yml ``` 3. Deploy the test data on the VM: ``` ansible-playbook -DK -i environments/development/allinone test.yml ``` 4. Install the test dependencies ```bash virtualenv ~/yoda-test-venv source ~/yoda-test-venv/bin/activate cd yoda/test/tests python3 -m pip install selenium python3 -m pip install -r requirements.yml ``` 4. Run the tests (in the `yoda/test/tests` directory) ```bash test -d /tmp/cache || mkdir -p /tmp/cache python3 -m pytest -o cache_dir=/tmp/cache ``` ## Alternative way of mounting the ruleset folder on Linux systems Mount vagrant guest folder on host (e.g. `/etc/irods/yoda-ruleset/` so you can run `pytest` on the local machine): ```bash # Mount sshfs -o IdentityFile=/home/dev/.vagrant.d/insecure_private_key -p 2222 vagrant@127.0.0.1:/etc/irods/yoda-ruleset yoda-ruleset # Umount fusermount -u yoda-ruleset ``` ",
    "url": "/yoda/development/running-api-ui-tests.html",
    "relUrl": "/development/running-api-ui-tests.html"
  }
}
